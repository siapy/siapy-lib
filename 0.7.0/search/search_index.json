{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to SiaPy","text":"<p> Spectral imaging analysis for Python (SiaPy) is a tool for efficient processing of spectral images </p> <p> </p> <p>Source Code: https://github.com/siapy/siapy-lib</p> <p>Bug Report / Feature Request: https://github.com/siapy/siapy-lib/issues/new/choose</p> <p>Documentation: https://siapy.github.io/siapy-lib/</p>"},{"location":"#overview","title":"\ud83d\udcda Overview","text":"<p>SiaPy is a versatile Python library designed for processing and analyzing spectral images. It is particularly useful for scientific and academic purposes, but it also serves well for quick prototyping.</p> <p>Built on top of the well-known spectral library, SiaPy extends its capabilities with additional features and functionalities.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Image Processing: Easily read, display, and manipulate spectral image data.</li> <li>Data Analysis: Perform in-depth analysis of spectral signatures using advanced analytical techniques.</li> <li>Machine Learning Integration: Select image regions for training models and segment images using pre-trained models.</li> <li>Camera Co-registration: Align multiple cameras and compute transformations across different camera spaces.</li> <li>Radiometric Conversion: Convert radiance to reflectance using reference panels.</li> </ul> <p>To make some of the functionality more easily accessible, a command line interface (CLI) is also provided. See siapy-cli. However, the full functionality can be exploited by using the library directly.</p>"},{"location":"#installation","title":"\ud83d\udca1 Installation","text":"<p>To install the siapy library, use the following command:</p> <pre><code>pip install siapy\n</code></pre> <p>For detailed information and additional options, please refer to the instructions.</p>"},{"location":"#examples","title":"\ud83d\udcbb Examples","text":"<pre><code>from pathlib import Path\nfrom siapy.entities import SpectralImageSet\n\ndata_dir = \"~/data\"\n\nheader_paths = sorted(Path(data_dir).rglob(\"*.hdr\"))\nimage_paths = sorted(Path(data_dir).rglob(\"*.img\"))\n\nimageset = SpectralImageSet.from_paths(\n    header_paths=header_paths,\n    image_paths=image_paths,\n)\nprint(imageset)\n</code></pre> <p>For an overview of the key concepts and functionalities of the SiaPy library, please refer to the documentation. Additionally, explore the use cases that demonstrate the library's capabilities here.</p>"},{"location":"#contribution-guidelines","title":"\ud83d\udd0d Contribution guidelines","text":"<p>We always welcome small improvements or fixes. If you\u2019re considering making more significant contributions to the source code, please contact us via email.</p> <p>Contributing to SiaPy isn\u2019t limited to coding. You can also:</p> <ul> <li>Help us manage and resolve issues, both new and existing.</li> <li>Create tutorials, presentations, and other educational resources.</li> <li>Propose new features.</li> </ul> <p>Not sure where to start or how your skills might fit in? Don\u2019t hesitate to reach out! You can contact us via email, or connect with us directly on GitHub by opening a new issue or commenting on an existing one.</p> <p>If you\u2019re new to open-source contributions, check out our guide for helpful tips on getting started.</p>"},{"location":"#issues-and-new-features","title":"\ud83d\udd50 Issues and new features","text":"<p>Encountered a problem with the library? Please report it by creating an issue on GitHub.</p> <p>Interested in fixing an issue or enhancing the library\u2019s functionality? Fork the repository, make your changes, and submit a pull request on GitHub.</p> <p>Have a question? First, ensure that the setup process was completed successfully and resolve any related issues. If you\u2019ve pulled in newer code, you might need to delete and recreate your SiaPy environment to ensure all the necessary packages are correctly installed.</p>"},{"location":"#license","title":"\ud83e\udd1d License","text":"<p>This project is licensed under the MIT License. See LICENSE for more details.</p>"},{"location":"changelog/","title":"Release Notes","text":""},{"location":"changelog/#070-2025-04-09","title":"0.7.0 (2025-04-09)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>add to_xarray method to ImageBase and implementations in RasterioLibImage and SpectralLibImage; enhance tests for new functionality (0663f75)</li> <li>enhance Pixels and Signatures classes with repr methods; remove SignaturesFilter class and update related tests (19d212f)</li> <li>enhance Shape class with get_pixels from convex hull (fefeca2)</li> <li>introduce Shape class and ShapeGeometryEnum for geometric representations (8e33634)</li> <li>refactor shape handling; replace Shapefile with Shape and add tests (381028d)</li> <li>shape handling and pixel coordinates (f7d48c9)</li> <li>update pixel class; add validators for initialization (2bd2710)</li> <li>update SpectralImageSet methods to use spy_open; add rasterio_o\u2026 (ad3aaaf)</li> <li>update SpectralImageSet methods to use spy_open; add rasterio_open method and corresponding tests (b61c2e8)</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>add missing XarrayType to the public API in types.py (eab41ee)</li> <li>add row and column properties to RasterioLibImage class; enhance tests for new properties (a871485)</li> <li>implement rasterio_open method in SpectralImage class; add corresponding tests (2b0e82f)</li> <li>update pre-commit installation command to include all hook types (41faf02)</li> </ul>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>update pdm.lock and add shapely dependency in pyproject.toml (534e639)</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>enhance copilot instructions with additional naming conventions (0d7600d)</li> <li>update documentation structure by removing obsolete shapefiles and shapes entries, and adding shape details (5677b4f)</li> </ul>"},{"location":"changelog/#060-2025-03-22","title":"0.6.0 (2025-03-22)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>add compress-data target to Makefile and enhance compression script with versioning (910f7e9)</li> <li>add script to compress test data and generate checksum (865ea02)</li> <li>add Shapefile entity with loading and geometry handling capabilities; update exceptions for filepath validation (20bd3fc)</li> <li>add SpectralLibImage support and update image loading methods (04e4b72)</li> <li>add TestDataManager class for managing test data downloads and verification; enhance compress-data script with git tagging (d00b0da)</li> <li>implement RasterioLibImage for raster file handling; update ImageBase interface and add tests (a6df199)</li> <li>implementation of spectral images base class (d333c44)</li> <li>integrate xarray support in rasterio and spectral libraries (37bac16)</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>correct spelling of \"coordinate\" in Coordinates class annotations (bb26fef)</li> <li>improve error handling in SpectralLibImage.open method (4cec71e)</li> <li>improve test data integrity verification and extraction process in data_manager.py (9817bd2)</li> <li>include docs/examples/src in linting and formatting scripts (3889e81)</li> <li>optimize image processing in RasterioLibImage and update nan handling in SpectralLibImage (2ffb19b)</li> <li>remove Git LFS checkout option from workflow and integrate test data integrity verification in pytest configuration (e3ad547)</li> <li>update pre-commit configuration to include tests directory for linting (c26cdd0)</li> <li>update Python version in workflow configurations from 3.10 to 3.12 (381ed36)</li> <li>update Python version in workflow configurations from 3.10 to 3.12 (3e4287c)</li> <li>update Python version in workflow configurations from 3.10 to 3.12 (db90263)</li> <li>update Python version range in pdm.lock to support 3.10 and below 3.13 (80187de)</li> <li>update type hint for open method in ImageBase class; remove TypeVar (4234dc5)</li> </ul>"},{"location":"changelog/#dependencies_1","title":"Dependencies","text":"<ul> <li>add geopandas, rasterio, and xarray as dependencies in pyproject.toml (1c7cfde)</li> <li>add types-shapely dependency for improved type checking in linting (88f0070)</li> <li>remove unused lint dependencies from pdm.lock and pyproject.toml (53b00e1)</li> <li>update configuration files for improved performance -- pdm update (4f060d4)</li> <li>update dependencies and add new testing packages in pdm.lock and pyproject.toml (da716ed)</li> </ul>"},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>reorganize API documentation structure for images and shapefiles (52e6446)</li> </ul>"},{"location":"changelog/#059-2025-01-15","title":"0.5.9 (2025-01-15)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>rename fit_params to params in Scorer and cross_validation functions (4ce6a76)</li> </ul>"},{"location":"changelog/#dependencies_2","title":"Dependencies","text":"<ul> <li>update configuration files for improved linting and formatting (ecdc54b)</li> </ul>"},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>add overview and key features to README.md (1b1fd70)</li> </ul>"},{"location":"changelog/#058-2024-12-23","title":"0.5.8 (2024-12-23)","text":""},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li>add use cases documentation for SiaPy library and update navigation (333bb9d)</li> <li>enhance examples with visualization scripts and update navigation (42fc4b0)</li> <li>update README with installation instructions and add example usage (5180335)</li> <li>update use cases documentation to clarify code repository links (b205431)</li> </ul>"},{"location":"changelog/#057-2024-12-20","title":"0.5.7 (2024-12-20)","text":""},{"location":"changelog/#documentation_4","title":"Documentation","text":"<ul> <li>add example for loading and processing a spectral image set (2564e88)</li> <li>add example script for loading and using SpectralImage (24d5a4b)</li> <li>add examples for loading and processing spectral images (3261665)</li> <li>enhance examples for loading and processing spectral images (09600b0)</li> <li>update data directory paths in example scripts and add transformations examples (d2e924f)</li> <li>update introduction.md with correct Zenodo link and improve formatting (15349d6)</li> </ul>"},{"location":"changelog/#056-2024-12-20","title":"0.5.6 (2024-12-20)","text":""},{"location":"changelog/#dependencies_3","title":"Dependencies","text":"<ul> <li>update dependencies and metadata in pdm.lock and pyproject.toml (0ceea41)</li> </ul>"},{"location":"changelog/#documentation_5","title":"Documentation","text":"<ul> <li>introduction.md (a6faef3)</li> </ul>"},{"location":"changelog/#055-2024-10-10","title":"0.5.5 (2024-10-10)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Update n_jobs default value to use all processors (e768b93)</li> </ul>"},{"location":"changelog/#054-2024-09-18","title":"0.5.4 (2024-09-18)","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Refactor, add and correct type annotations (12ffa05)</li> </ul>"},{"location":"changelog/#documentation_6","title":"Documentation","text":"<ul> <li>Add core.exceptions API documentation and update mkdocs.yml (ca37d04)</li> </ul>"},{"location":"changelog/#053-2024-09-17","title":"0.5.3 (2024-09-17)","text":""},{"location":"changelog/#dependencies_4","title":"Dependencies","text":"<ul> <li>pdm update (5fcea60)</li> <li>To indicate that your library supports type checking (72425aa)</li> </ul>"},{"location":"changelog/#052-2024-09-03","title":"0.5.2 (2024-09-03)","text":""},{"location":"changelog/#performance-improvements","title":"Performance Improvements","text":"<ul> <li>Refactor code to improve performance in test_to_signatures_perf (39cf7a2)</li> </ul>"},{"location":"changelog/#documentation_7","title":"Documentation","text":"<ul> <li>funding update (bfdbc65)</li> <li>Update funding configuration file (bfdbc65)</li> </ul>"},{"location":"changelog/#051-2024-08-28","title":"0.5.1 (2024-08-28)","text":""},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Comment out cache-related code in docs.yml workflow --temporary fix (51a8e11)</li> <li>Remove unused siapy version file and update installation instructions (8e966e3)</li> </ul>"},{"location":"changelog/#050-2024-08-28","title":"0.5.0 (2024-08-28)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Add load_from_parquet and save_to_parquet methods to Pixels class (9d106cb)</li> <li>Add load_from_parquet and save_to_parquet methods to Signals class (47ccb2c)</li> <li>Add load_from_parquet and save_to_parquet methods to Signatures class (ce30e67)</li> </ul>"},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>Update save_to_parquet method to include index in the saved file (36981a5)</li> <li>Update typing annotations in from_paths (c827862)</li> </ul>"},{"location":"changelog/#documentation_8","title":"Documentation","text":"<ul> <li>Update installation instructions with additional package managers (bf238a3)</li> </ul>"},{"location":"changelog/#049-2024-08-22","title":"0.4.9 (2024-08-22)","text":""},{"location":"changelog/#documentation_9","title":"Documentation","text":"<ul> <li>Update installation instructions and troubleshooting section (f5378c1)</li> </ul>"},{"location":"changelog/#048-2024-08-22","title":"0.4.8 (2024-08-22)","text":""},{"location":"changelog/#reverts","title":"Reverts","text":"<ul> <li>fix codespell config (fd2854e)</li> </ul>"},{"location":"changelog/#documentation_10","title":"Documentation","text":"<ul> <li>change path to logo image (b316fc0)</li> <li>Update page title in mkdocs.yml (aa1b221)</li> </ul>"},{"location":"changelog/#047-2024-08-20","title":"0.4.7 (2024-08-20)","text":""},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>Update license to MIT License in docs directly (4ee1772)</li> </ul>"},{"location":"changelog/#046-2024-08-20","title":"0.4.6 (2024-08-20)","text":""},{"location":"changelog/#documentation_11","title":"Documentation","text":"<ul> <li>Update links in README and mkdocs.yml (dead861)</li> </ul>"},{"location":"changelog/#045-2024-08-20","title":"0.4.5 (2024-08-20)","text":""},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>deploying MkDocs action fail fix (35e5a7b)</li> </ul>"},{"location":"changelog/#044-2024-08-20","title":"0.4.4 (2024-08-20)","text":""},{"location":"changelog/#documentation_12","title":"Documentation","text":"<ul> <li>Add new API documentation files (19fe2cc)</li> <li>index docs page update with default readme file (eb6703b)</li> </ul>"},{"location":"changelog/#043-2024-08-20","title":"0.4.3 (2024-08-20)","text":""},{"location":"changelog/#dependencies_5","title":"Dependencies","text":"<ul> <li>Update dependencies for documentation improvements (8d98dc1)</li> </ul>"},{"location":"changelog/#documentation_13","title":"Documentation","text":"<ul> <li>Make docs for dev (#111) (8fc65f1)</li> <li>Update site_url in mkdocs.yml (1fcb70d)</li> </ul>"},{"location":"changelog/#042-2024-08-18","title":"0.4.2 (2024-08-18)","text":""},{"location":"changelog/#documentation_14","title":"Documentation","text":"<ul> <li>logo image path changed (76d8850)</li> </ul>"},{"location":"changelog/#041-2024-08-12","title":"0.4.1 (2024-08-12)","text":""},{"location":"changelog/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li>mypy fix (0b421fe)</li> </ul>"},{"location":"changelog/#dependencies_6","title":"Dependencies","text":"<ul> <li>pdm update (a49ef58)</li> </ul>"},{"location":"changelog/#documentation_15","title":"Documentation","text":"<ul> <li>Update copyright year to 2024 (672274f)</li> </ul>"},{"location":"changelog/#040-2024-08-10","title":"0.4.0 (2024-08-10)","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Add spectral indices computation and calculation functions (3ef8c63)</li> <li>Features generation implemented - automatic and spectral indices (16365e0)</li> </ul>"},{"location":"changelog/#bug-fixes_10","title":"Bug Fixes","text":"<ul> <li>include (6d7e9e5)</li> <li>Remove unnecessary dataclass decorator brackets (28143f3)</li> <li>stubs for spyndex, mlxtend, and autofeat (f89a22a)</li> </ul>"},{"location":"changelog/#dependencies_7","title":"Dependencies","text":"<ul> <li>Update dependencies to include spyndex, mlxtend, and autofeat (edd4978)</li> </ul>"},{"location":"changelog/#034-2024-07-26","title":"0.3.4 (2024-07-26)","text":""},{"location":"changelog/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li>Create Target base class (cf7194d)</li> <li>set default direction for optimization to 'minimize' (5a402fd)</li> <li>Update evaluators.py with type annotations and error handling (b1a4010)</li> <li>Update study config defaults to set direction to 'minimize' (347a2bb)</li> </ul>"},{"location":"changelog/#dependencies_8","title":"Dependencies","text":"<ul> <li>Update pyproject.toml with optuna&gt;=3.6.1 dependency (1faac14)</li> </ul>"},{"location":"changelog/#documentation_16","title":"Documentation","text":"<ul> <li>Update default branch name to 'main' and adjust merge instructions (42b0e29)</li> </ul>"},{"location":"changelog/#033-2024-07-16","title":"0.3.3 (2024-07-16)","text":""},{"location":"changelog/#bug-fixes_12","title":"Bug Fixes","text":"<ul> <li>Add shape_type property to Shape class; fix tests (0fccc9a)</li> </ul>"},{"location":"changelog/#032-2024-07-08","title":"0.3.2 (2024-07-08)","text":""},{"location":"changelog/#bug-fixes_13","title":"Bug Fixes","text":"<ul> <li>Update mypy configuration to ignore missing imports for sklearn module (15ad789)</li> </ul>"},{"location":"changelog/#031-2024-07-08","title":"0.3.1 (2024-07-08)","text":""},{"location":"changelog/#bug-fixes_14","title":"Bug Fixes","text":"<ul> <li>Update gitignore to include tests/data directory and ignore E501 in flake8 configuration (3664bd1)</li> </ul>"},{"location":"changelog/#030-2024-07-06","title":"0.3.0 (2024-07-06)","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>Add camera_id property and images_by_camera_id method to SpectralImageSet (c7814dc)</li> </ul>"},{"location":"changelog/#bug-fixes_15","title":"Bug Fixes","text":"<ul> <li>add scope to fixtures. (9e2befd)</li> <li>Update indent_style and indent_size in .editorconfig (a3288dc)</li> </ul>"},{"location":"changelog/#024-2024-07-04","title":"0.2.4 (2024-07-04)","text":""},{"location":"changelog/#documentation_17","title":"Documentation","text":"<ul> <li>moved files from .github -&gt; repo root (b1a3989)</li> <li>security put in place (8585538)</li> </ul>"},{"location":"changelog/#023-2024-07-01","title":"0.2.3 (2024-07-01)","text":""},{"location":"changelog/#documentation_18","title":"Documentation","text":"<ul> <li>fixed annotations, added citation file (baa3628)</li> </ul>"},{"location":"changelog/#022-2024-06-30","title":"0.2.2 (2024-06-30)","text":""},{"location":"changelog/#bug-fixes_16","title":"Bug Fixes","text":"<ul> <li>adapt codespell settings to siapy project (70649e4)</li> <li>fixed test; linter add; dependencies upgrated (a8e8e8b)</li> <li>pyptoject.toml rename and add additional files to source pdm build (951f3f7)</li> <li>success flag added back and run_id (4e62181)</li> <li>Update codespell settings to exclude unnecessary directories (383792b)</li> </ul>"},{"location":"changelog/#documentation_19","title":"Documentation","text":"<ul> <li>conventional commits type description (d4f05bd)</li> <li>remove initial contributing readme (afd7e0b)</li> </ul>"},{"location":"changelog/#021-2024-06-29","title":"0.2.1 (2024-06-29)","text":""},{"location":"changelog/#bug-fixes_17","title":"Bug Fixes","text":"<ul> <li>added missing docs files (4cd628b)</li> </ul>"},{"location":"changelog/#020-2024-06-29","title":"0.2.0 (2024-06-29)","text":""},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>Add method to get a shape by name in GeometricShapes (1583a8d)</li> <li>Add pixel selection functionality and lasso tool for image plotting (fabc43b)</li> <li>Add scikit-image dependency for image processing and add image transformations. (a464ef7)</li> <li>Add Shape class for geometric shapes in SpectralImage (e1456c6)</li> <li>Add support for saving images with different data types and metadata (5d6d09c)</li> <li>Add test for transformation function and affine matrix generation (c9aa4e3)</li> <li>Add u(), v(), and to_numpy() methods to Pixels entity (e4aa9e2)</li> <li>Improve SpectralImage class by removing redundant code and optimizing image processing, test added (ea859f7)</li> <li>Move Corregistrator class to its own file and update imports (5286365)</li> <li>Refactor code to use preserve_range=True in image rotation and rescaling functions, implemented merge_by_spectral (217032b)</li> <li>Refactor Corregistrator class and add Pixels entity (59aafb0)</li> <li>Refactor GeometricShapes class to use a separate class for managing shapes, test added (5f32e0e)</li> <li>Refactor SignaturesFilter to allow filtering rows and columns (7d9e03c)</li> <li>Refactor SignaturesFilter to allow filtering rows and columns (ae2be44)</li> <li>separated validator functons. implemented test for image transformation (9fe2c1a)</li> </ul>"},{"location":"changelog/#bug-fixes_18","title":"Bug Fixes","text":"<ul> <li>Refactor code to use Path instead of ConvexHull for FreeDraw convex hull calculation, shapes tests added (2ddd253)</li> <li>rename plotting -&gt; plot (ac9a906)</li> <li>tests renamed to prepend the name of the directory (f91fe45)</li> </ul>"},{"location":"changelog/#documentation_20","title":"Documentation","text":"<ul> <li>templates (89e0a48)</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Guidelines for contributing</li> <li>Summary</li> <li>Git</li> <li>Python<ul> <li>Pdm</li> <li>Highlights</li> <li>Key commands</li> <li>Testing with pytest</li> </ul> </li> <li>GitHub Actions workflows</li> <li>Maintainers</li> </ul>"},{"location":"contributing/#summary","title":"Summary","text":"<p>PRs welcome!</p> <ul> <li>Consider starting a discussion to see if there's interest in what you want to do.</li> <li>Submit PRs from feature branches on forks to the <code>develop</code> branch.</li> <li>Ensure PRs pass all CI checks.</li> <li>Maintain test coverage at 100%.</li> </ul>"},{"location":"contributing/#git","title":"Git","text":"<ul> <li>Why use Git? Git enables creation of multiple versions of a code repository called branches, with the ability to track and undo changes in detail.</li> <li>Install Git by downloading from the website, or with a package manager like Homebrew.</li> <li>Configure Git to connect to GitHub with SSH.</li> <li>Fork this repo.</li> <li>Create a branch in your fork.</li> <li>Commit your changes with a properly-formatted Git commit message.</li> <li>Create a pull request (PR) to incorporate your changes into the upstream project you forked.</li> </ul>"},{"location":"contributing/#python","title":"Python","text":""},{"location":"contributing/#pdm","title":"Pdm","text":"<p>This project uses PDM for dependency management and packaging.</p>"},{"location":"contributing/#highlights","title":"Highlights","text":"<ul> <li>Automatic virtual environment management: Automatically manages the application environment.</li> <li>Dependency resolution: Automatically resolve any dependency version conflicts using the <code>pip</code> dependency resolver.</li> <li>Dependency separation: Supports separate lists of optional dependencies in the pyproject.toml. Production installs can skip optional dependencies for speed.</li> <li>Builds: Features for easily building the project into a Python package and publishing the package to PyPI.</li> </ul>"},{"location":"contributing/#key-commands","title":"Key commands","text":"<pre><code>pdm init  # Initialize a new project\npdm add PACKAGE_NAME  # Add a package to the project dependencies\npdm install  # Install dependencies from pyproject.toml\npdm list  # Show a list of installed packages\npdm run COMMAND  # Run a command within the PDM environment\npdm shell  # Activate the PDM environment, similar to activating a virtualenv\npdm sync  # Synchronize the project's dependencies\n</code></pre>"},{"location":"contributing/#testing-with-pytest","title":"Testing with pytest","text":"<ul> <li>Tests are in the tests/ directory.</li> <li>pytest features used include:</li> <li>capturing <code>stdout</code> with <code>capfd</code></li> <li>fixtures</li> <li>monkeypatch</li> <li>parametrize</li> <li>temporary directories and files (<code>tmp_path</code> and <code>tmp_dir</code>)</li> <li>pytest plugins include:</li> <li>pytest-mock</li> <li>pytest configuration is in pyproject.toml.</li> <li>Run tests with pytest</li> <li>Test coverage reports are generated by pytest-cov</li> </ul>"},{"location":"contributing/#github-actions-workflows","title":"GitHub Actions workflows","text":"<p>GitHub Actions is a continuous integration/continuous deployment (CI/CD) service that runs on GitHub repos. It replaces other services like Travis CI. Actions are grouped into workflows and stored in .github/workflows.</p>"},{"location":"contributing/#maintainers","title":"Maintainers","text":"<ul> <li>The default branch is <code>main</code>.</li> <li>PRs from feature branches should be merged into <code>develop</code>.</li> <li>The only merges to <code>main</code> should be PRs from <code>develop</code>.</li> <li>Branch protection is enabled on <code>develop</code> and <code>main</code>.</li> <li><code>develop</code>:<ul> <li>Require signed commits</li> <li>Include administrators</li> <li>Allow force pushes</li> </ul> </li> <li><code>main</code>:<ul> <li>Require signed commits</li> <li>Include administrators</li> <li>Do not allow force pushes</li> <li>Require status checks to pass before merging (commits must have previously been pushed to <code>develop</code> and passed all checks)</li> </ul> </li> <li>To commit:</li> <li>Follow the Conventional Commits specification for commit messages. This standardizes the commit history and facilitates automatic generation of the changelog.</li> <li> <p>Type must be one of the following:</p> <ul> <li><code>feat</code>: A new feature</li> <li><code>fix</code>: A bug fix</li> <li><code>perf</code>: A code change that improves performance</li> <li><code>deps</code>: Dependency updates</li> <li><code>revert</code>: Reverts a previous commit</li> <li><code>docs</code>: Documentation only changes</li> <li><code>style</code>: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc), hidden</li> <li><code>chore</code>: Miscellaneous chores, hidden</li> <li><code>refactor</code>: A code change that neither fixes a bug nor adds a feature, hidden</li> <li><code>test</code>: Adding missing tests or correcting existing tests, hidden</li> <li><code>build</code>: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm), hidden</li> <li><code>ci</code>: Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs), hidden</li> </ul> </li> <li> <p>Ensure your commit messages clearly describe the changes made and follow the format <code>type(scope?): subject</code>, where <code>scope</code> is optional.</p> </li> <li> <p>To create a release:</p> </li> <li>Follow SemVer guidelines when choosing a version number. Note that PEP 440 Python version specifiers and SemVer version specifiers differ, particularly with regard to specifying prereleases. Use syntax compatible with both.</li> <li>The PEP 440 default (like <code>1.0.0a0</code>) is different from SemVer.</li> <li>An alternative form of the Python prerelease syntax permitted in PEP 440 (like <code>1.0.0-alpha.0</code>) is compatible with SemVer, and this form should be used when tagging releases.</li> <li>Examples of acceptable tag names: <code>1.0.0</code>, <code>1.0.0-alpha.0</code>, <code>1.0.0-beta.1</code></li> <li>Push to <code>develop</code> and verify all CI checks pass.</li> <li>Fast-forward merge to <code>main</code>, push, and verify all CI checks pass.</li> </ul>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#prerequisites","title":"Prerequisites","text":"<p>Before installing <code>siapy</code> library, ensure you have the following prerequisites:</p> <ul> <li>Python 3.10 or higher</li> <li><code>pip</code> (Python package installer) or any other installer (e.g. pdm, uv, poetry)</li> </ul>"},{"location":"install/#installation","title":"Installation","text":"<p>Installation is as simple as:</p> <pre><code>pip install siapy\n</code></pre>"},{"location":"install/#alternative-installation-methods","title":"Alternative Installation Methods","text":"<p>Python package and dependency managers</p> <p>You can also install siapy using other popular Python package and dependency managers:</p> <ul> <li>PDM:</li> </ul> <pre><code>pdm add siapy\n</code></pre> <ul> <li>Poetry:</li> </ul> <pre><code>poetry add siapy\n</code></pre> <ul> <li>uv:</li> </ul> <pre><code>uv add siapy\n</code></pre> <p>Manually</p> <p>If you prefer to install from the source, you can clone the repository and install it manually:</p> <pre><code>git clone https://github.com/siapy/siapy-lib.git\ncd siapy\nmake install\n</code></pre>"},{"location":"install/#verify-installation","title":"Verify Installation","text":"<p>To verify that siapy has been installed correctly, you can run:</p> <pre><code>python -c \"import siapy; print(siapy.__version__)\"\n</code></pre>"},{"location":"install/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues during installation, consider the following solutions:</p> <ul> <li>Ensure that you have the correct version of Python installed.</li> <li>Check for any missing dependencies and install them manually.</li> <li>Upgrade pip to the latest version:</li> </ul> <pre><code>pip install --upgrade pip\n</code></pre> <p>For further assistance, please refer to the documentation or open an issue on GitHub.</p>"},{"location":"permit/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 SiaPy, Agricultural institute of Slovenia</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api/core/configs/","title":"Configs","text":""},{"location":"api/core/configs/#siapy.core.configs","title":"siapy.core.configs","text":""},{"location":"api/core/configs/#siapy.core.configs.BASE_DIR","title":"BASE_DIR  <code>module-attribute</code>","text":"<pre><code>BASE_DIR = absolute()\n</code></pre>"},{"location":"api/core/configs/#siapy.core.configs.SIAPY_DIR","title":"SIAPY_DIR  <code>module-attribute</code>","text":"<pre><code>SIAPY_DIR = Path(BASE_DIR, 'siapy')\n</code></pre>"},{"location":"api/core/configs/#siapy.core.configs.TEST_DATA_DIR","title":"TEST_DATA_DIR  <code>module-attribute</code>","text":"<pre><code>TEST_DATA_DIR = Path(BASE_DIR, 'tests', 'data')\n</code></pre>"},{"location":"api/core/exceptions/","title":"Exceptions","text":""},{"location":"api/core/exceptions/#siapy.core.exceptions","title":"siapy.core.exceptions","text":""},{"location":"api/core/exceptions/#siapy.core.exceptions.SiapyError","title":"SiapyError","text":"<pre><code>SiapyError(message: str, name: str = 'SiaPy')\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base exception for SiaPy library.</p> Source code in <code>siapy/core/exceptions.py</code> <pre><code>def __init__(self, message: str, name: str = \"SiaPy\") -&gt; None:\n    self.message: str = message\n    self.name: str = name\n    super().__init__(self.message, self.name)\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.SiapyError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str = message\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.SiapyError.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidFilepathError","title":"InvalidFilepathError","text":"<pre><code>InvalidFilepathError(filename: str | Path)\n</code></pre> <p>               Bases: <code>SiapyError</code></p> <p>Exception raised when a required file is not found.</p> Source code in <code>siapy/core/exceptions.py</code> <pre><code>def __init__(self, filename: str | Path) -&gt; None:\n    self.filename: str = str(filename)\n    super().__init__(f\"File not found: {filename}\")\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidFilepathError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str = message\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidFilepathError.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidFilepathError.filename","title":"filename  <code>instance-attribute</code>","text":"<pre><code>filename: str = str(filename)\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidInputError","title":"InvalidInputError","text":"<pre><code>InvalidInputError(input_value: Any, message: str = 'Invalid input')\n</code></pre> <p>               Bases: <code>SiapyError</code></p> <p>Exception raised for invalid input.</p> Source code in <code>siapy/core/exceptions.py</code> <pre><code>def __init__(self, input_value: Any, message: str = \"Invalid input\") -&gt; None:\n    self.input_value: Any = input_value\n    self.message: str = message\n    super().__init__(f\"{message}: {input_value}\")\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidInputError.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidInputError.input_value","title":"input_value  <code>instance-attribute</code>","text":"<pre><code>input_value: Any = input_value\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidInputError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str = message\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidTypeError","title":"InvalidTypeError","text":"<pre><code>InvalidTypeError(input_value: Any, allowed_types: type | tuple[type, ...], message: str = 'Invalid type')\n</code></pre> <p>               Bases: <code>SiapyError</code></p> <p>Exception raised for invalid type.</p> Source code in <code>siapy/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    input_value: Any,\n    allowed_types: type | tuple[type, ...],\n    message: str = \"Invalid type\",\n) -&gt; None:\n    self.input_value: Any = input_value\n    self.input_type: Any = type(input_value)\n    self.allowed_types: type | tuple[type, ...] = allowed_types\n    self.message: str = message\n    super().__init__(f\"{message}: {input_value} (type: {self.input_type}). Allowed types: {allowed_types}\")\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidTypeError.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidTypeError.input_value","title":"input_value  <code>instance-attribute</code>","text":"<pre><code>input_value: Any = input_value\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidTypeError.input_type","title":"input_type  <code>instance-attribute</code>","text":"<pre><code>input_type: Any = type(input_value)\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidTypeError.allowed_types","title":"allowed_types  <code>instance-attribute</code>","text":"<pre><code>allowed_types: type | tuple[type, ...] = allowed_types\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.InvalidTypeError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str = message\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.ProcessingError","title":"ProcessingError","text":"<pre><code>ProcessingError(message: str = 'An error occurred during processing')\n</code></pre> <p>               Bases: <code>SiapyError</code></p> <p>Exception raised for errors during processing.</p> Source code in <code>siapy/core/exceptions.py</code> <pre><code>def __init__(self, message: str = \"An error occurred during processing\") -&gt; None:\n    self.message: str = message\n    super().__init__(message)\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.ProcessingError.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.ProcessingError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str = message\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.ConfigurationError","title":"ConfigurationError","text":"<pre><code>ConfigurationError(message: str = 'Configuration error')\n</code></pre> <p>               Bases: <code>SiapyError</code></p> <p>Exception raised for configuration errors.</p> Source code in <code>siapy/core/exceptions.py</code> <pre><code>def __init__(self, message: str = \"Configuration error\") -&gt; None:\n    self.message: str = message\n    super().__init__(message)\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.ConfigurationError.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.ConfigurationError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str = message\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.MethodNotImplementedError","title":"MethodNotImplementedError","text":"<pre><code>MethodNotImplementedError(class_name: str, method_name: str)\n</code></pre> <p>               Bases: <code>SiapyError</code></p> <p>Exception raised for not implemented methods.</p> Source code in <code>siapy/core/exceptions.py</code> <pre><code>def __init__(self, class_name: str, method_name: str) -&gt; None:\n    self.class_name: str = class_name\n    self.method_name: str = method_name\n    super().__init__(f\"Method '{method_name}' not implemented in class '{class_name}'\")\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.MethodNotImplementedError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str = message\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.MethodNotImplementedError.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.MethodNotImplementedError.class_name","title":"class_name  <code>instance-attribute</code>","text":"<pre><code>class_name: str = class_name\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.MethodNotImplementedError.method_name","title":"method_name  <code>instance-attribute</code>","text":"<pre><code>method_name: str = method_name\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.DirectInitializationError","title":"DirectInitializationError","text":"<pre><code>DirectInitializationError(class_: type)\n</code></pre> <p>               Bases: <code>SiapyError</code></p> <p>Exception raised when a class method is required to create an instance.</p> Source code in <code>siapy/core/exceptions.py</code> <pre><code>def __init__(self, class_: type) -&gt; None:\n    from siapy.utils.general import get_classmethods\n\n    self.class_name: str = class_.__class__.__name__\n    self.class_methods: list[str] = get_classmethods(class_)\n    super().__init__(\n        f\"Use any of the @classmethod to create a new instance of '{self.class_name}': {self.class_methods}\"\n    )\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.DirectInitializationError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str = message\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.DirectInitializationError.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.DirectInitializationError.class_name","title":"class_name  <code>instance-attribute</code>","text":"<pre><code>class_name: str = __name__\n</code></pre>"},{"location":"api/core/exceptions/#siapy.core.exceptions.DirectInitializationError.class_methods","title":"class_methods  <code>instance-attribute</code>","text":"<pre><code>class_methods: list[str] = get_classmethods(class_)\n</code></pre>"},{"location":"api/core/logger/","title":"Logger","text":""},{"location":"api/core/logger/#siapy.core.logger","title":"siapy.core.logger","text":""},{"location":"api/core/logger/#siapy.core.logger.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('siapy')\n</code></pre>"},{"location":"api/core/types/","title":"Types","text":""},{"location":"api/core/types/#siapy.core.types","title":"siapy.core.types","text":""},{"location":"api/core/types/#siapy.core.types.SpectralLibType","title":"SpectralLibType  <code>module-attribute</code>","text":"<pre><code>SpectralLibType = BilFile | BipFile | BsqFile\n</code></pre>"},{"location":"api/core/types/#siapy.core.types.XarrayType","title":"XarrayType  <code>module-attribute</code>","text":"<pre><code>XarrayType = DataArray | Dataset\n</code></pre>"},{"location":"api/core/types/#siapy.core.types.ImageType","title":"ImageType  <code>module-attribute</code>","text":"<pre><code>ImageType = SpectralImage | ndarray | Image\n</code></pre>"},{"location":"api/core/types/#siapy.core.types.ImageSizeType","title":"ImageSizeType  <code>module-attribute</code>","text":"<pre><code>ImageSizeType = int | tuple[int, ...]\n</code></pre>"},{"location":"api/core/types/#siapy.core.types.ImageDataType","title":"ImageDataType  <code>module-attribute</code>","text":"<pre><code>ImageDataType = uint8 | int16 | int32 | float32 | float64 | complex64 | complex128 | uint16 | uint32 | int64 | uint64\n</code></pre>"},{"location":"api/core/types/#siapy.core.types.ImageContainerType","title":"ImageContainerType  <code>module-attribute</code>","text":"<pre><code>ImageContainerType = SpectralImage | SpectralImageSet\n</code></pre>"},{"location":"api/core/types/#siapy.core.types.ArrayLike1dType","title":"ArrayLike1dType  <code>module-attribute</code>","text":"<pre><code>ArrayLike1dType = ndarray | Series | Sequence[Any] | ArrayLike\n</code></pre>"},{"location":"api/core/types/#siapy.core.types.ArrayLike2dType","title":"ArrayLike2dType  <code>module-attribute</code>","text":"<pre><code>ArrayLike2dType = ndarray | DataFrame | Sequence[Any] | ArrayLike\n</code></pre>"},{"location":"api/datasets/helpers/","title":"Helpers","text":""},{"location":"api/datasets/helpers/#siapy.datasets.helpers","title":"siapy.datasets.helpers","text":""},{"location":"api/datasets/helpers/#siapy.datasets.helpers.generate_classification_target","title":"generate_classification_target","text":"<pre><code>generate_classification_target(dataframe: DataFrame, column_names: str | list[str]) -&gt; ClassificationTarget\n</code></pre> Source code in <code>siapy/datasets/helpers.py</code> <pre><code>def generate_classification_target(\n    dataframe: pd.DataFrame,\n    column_names: str | list[str],\n) -&gt; \"ClassificationTarget\":\n    from .schemas import (\n        ClassificationTarget,  # Local import to avoid circular dependency\n    )\n\n    if isinstance(column_names, str):\n        column_names = [column_names]\n    # create one column labels from multiple columns\n    label = dataframe[column_names].apply(tuple, axis=1)\n    # Convert tuples to strings with '__' delimiter\n    label = label.apply(lambda x: \"__\".join(x))\n    # encode to numbers\n    encoded_np, encoding_np = pd.factorize(label)\n    encoded = pd.Series(encoded_np, name=\"encoded\")\n    encoding = pd.Series(encoding_np, name=\"encoding\")\n    return ClassificationTarget(label=label, value=encoded, encoding=encoding)\n</code></pre>"},{"location":"api/datasets/helpers/#siapy.datasets.helpers.generate_regression_target","title":"generate_regression_target","text":"<pre><code>generate_regression_target(dataframe: DataFrame, column_name: str) -&gt; RegressionTarget\n</code></pre> Source code in <code>siapy/datasets/helpers.py</code> <pre><code>def generate_regression_target(\n    dataframe: pd.DataFrame,\n    column_name: str,\n) -&gt; \"RegressionTarget\":\n    from .schemas import (\n        RegressionTarget,\n    )  # Local import to avoid circular dependency\n\n    return RegressionTarget(name=column_name, value=dataframe[column_name])\n</code></pre>"},{"location":"api/datasets/helpers/#siapy.datasets.helpers.merge_signals_from_multiple_cameras","title":"merge_signals_from_multiple_cameras","text":"<pre><code>merge_signals_from_multiple_cameras(data: TabularDatasetData)\n</code></pre> Source code in <code>siapy/datasets/helpers.py</code> <pre><code>def merge_signals_from_multiple_cameras(data: \"TabularDatasetData\"):\n    data.signals.copy()\n</code></pre>"},{"location":"api/datasets/schemas/","title":"Schemas","text":""},{"location":"api/datasets/schemas/#siapy.datasets.schemas","title":"siapy.datasets.schemas","text":""},{"location":"api/datasets/schemas/#siapy.datasets.schemas.Target","title":"Target","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.Target.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.Target.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Series\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.Target.from_dict","title":"from_dict  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[str, Any]) -&gt; Target\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; \"Target\": ...\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.Target.from_iterable","title":"from_iterable  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_iterable(data: Iterable) -&gt; Target\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_iterable(cls, data: Iterable) -&gt; \"Target\": ...\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.Target.to_dict","title":"to_dict  <code>abstractmethod</code>","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>@abstractmethod\ndef to_dict(self) -&gt; dict[str, Any]: ...\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.Target.to_dataframe","title":"to_dataframe  <code>abstractmethod</code>","text":"<pre><code>to_dataframe() -&gt; DataFrame\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>@abstractmethod\ndef to_dataframe(self) -&gt; pd.DataFrame: ...\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.Target.reset_index","title":"reset_index  <code>abstractmethod</code>","text":"<pre><code>reset_index() -&gt; Target\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>@abstractmethod\ndef reset_index(self) -&gt; \"Target\": ...\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.ClassificationTarget","title":"ClassificationTarget","text":"<p>               Bases: <code>Target</code></p>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.ClassificationTarget.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.ClassificationTarget.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: Series\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.ClassificationTarget.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Series\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.ClassificationTarget.encoding","title":"encoding  <code>instance-attribute</code>","text":"<pre><code>encoding: Series\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.ClassificationTarget.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(data: Iterable) -&gt; ClassificationTarget\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>@classmethod\ndef from_iterable(cls, data: Iterable) -&gt; \"ClassificationTarget\":\n    label = pd.DataFrame(data, columns=[\"label\"])\n    return generate_classification_target(label, \"label\")\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.ClassificationTarget.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[str, Any]) -&gt; ClassificationTarget\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; \"ClassificationTarget\":\n    label = pd.Series(data[\"label\"], name=\"label\")\n    value = pd.Series(data[\"value\"], name=\"value\")\n    encoding = pd.Series(data[\"encoding\"], name=\"encoding\")\n    return cls(label=label, value=value, encoding=encoding)\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.ClassificationTarget.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    return {\n        \"label\": self.label.to_list(),\n        \"value\": self.value.to_list(),\n        \"encoding\": self.encoding.to_list(),\n    }\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.ClassificationTarget.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe() -&gt; DataFrame\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>def to_dataframe(self) -&gt; pd.DataFrame:\n    return pd.concat([self.value, self.label], axis=1)\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.ClassificationTarget.reset_index","title":"reset_index","text":"<pre><code>reset_index() -&gt; ClassificationTarget\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>def reset_index(self) -&gt; \"ClassificationTarget\":\n    return ClassificationTarget(\n        label=self.label.reset_index(drop=True),\n        value=self.value.reset_index(drop=True),\n        encoding=self.encoding,\n    )\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.RegressionTarget","title":"RegressionTarget","text":"<p>               Bases: <code>Target</code></p>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.RegressionTarget.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.RegressionTarget.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Series\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.RegressionTarget.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.RegressionTarget.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(data: Iterable) -&gt; RegressionTarget\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>@classmethod\ndef from_iterable(cls, data: Iterable) -&gt; \"RegressionTarget\":\n    value = pd.DataFrame(data, columns=[\"value\"])\n    return generate_regression_target(value, \"value\")\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.RegressionTarget.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[str, Any]) -&gt; RegressionTarget\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; \"RegressionTarget\":\n    value = pd.Series(data[\"value\"], name=\"value\")\n    name = data[\"name\"]\n    return cls(value=value, name=name)\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.RegressionTarget.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    return {\n        \"value\": self.value.to_list(),\n        \"name\": self.name,\n    }\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.RegressionTarget.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe() -&gt; DataFrame\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>def to_dataframe(self) -&gt; pd.DataFrame:\n    return pd.DataFrame(self.value)\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.RegressionTarget.reset_index","title":"reset_index","text":"<pre><code>reset_index() -&gt; RegressionTarget\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>def reset_index(self) -&gt; \"RegressionTarget\":\n    return RegressionTarget(value=self.value.reset_index(drop=True), name=self.name)\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.TabularDatasetData","title":"TabularDatasetData","text":"<pre><code>TabularDatasetData(*args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any):\n    super().__init__(*args, **kwargs)\n    self._validate_lengths()\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.TabularDatasetData.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.TabularDatasetData.pixels","title":"pixels  <code>instance-attribute</code>","text":"<pre><code>pixels: DataFrame\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.TabularDatasetData.signals","title":"signals  <code>instance-attribute</code>","text":"<pre><code>signals: DataFrame\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.TabularDatasetData.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata: DataFrame\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.TabularDatasetData.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>target: Target | None = None\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.TabularDatasetData.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[str, Any]) -&gt; TabularDatasetData\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; \"TabularDatasetData\":\n    pixels = pd.DataFrame(data[\"pixels\"])\n    signals = pd.DataFrame(data[\"signals\"])\n    metadata = pd.DataFrame(data[\"metadata\"])\n    target = TabularDatasetData.target_from_dict(data.get(\"target\", None))\n    return cls(pixels=pixels, signals=signals, metadata=metadata, target=target)\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.TabularDatasetData.target_from_dict","title":"target_from_dict  <code>staticmethod</code>","text":"<pre><code>target_from_dict(data: dict[str, Any] | None) -&gt; Target | None\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>@staticmethod\ndef target_from_dict(data: dict[str, Any] | None) -&gt; Target | None:\n    if data is None:\n        return None\n\n    regression_keys = set(RegressionTarget.model_fields.keys())\n    classification_keys = set(ClassificationTarget.model_fields.keys())\n    data_keys = set(data.keys())\n\n    if data_keys.issubset(regression_keys):\n        return RegressionTarget.from_dict(data)\n    elif data_keys.issubset(classification_keys):\n        return ClassificationTarget.from_dict(data)\n    else:\n        raise InvalidInputError(data, \"Invalid target dict.\")\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.TabularDatasetData.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    return {\n        \"pixels\": self.pixels.to_dict(),\n        \"signals\": self.signals.to_dict(),\n        \"metadata\": self.metadata.to_dict(),\n        \"target\": self.target.to_dict() if self.target is not None else None,\n    }\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.TabularDatasetData.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe() -&gt; DataFrame\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>def to_dataframe(self) -&gt; pd.DataFrame:\n    combined_df = pd.concat([self.pixels, self.signals, self.metadata], axis=1)\n    if self.target is not None:\n        target_series = self.target.to_dataframe()\n        combined_df = pd.concat([combined_df, target_series], axis=1)\n    return combined_df\n</code></pre>"},{"location":"api/datasets/schemas/#siapy.datasets.schemas.TabularDatasetData.reset_index","title":"reset_index","text":"<pre><code>reset_index() -&gt; TabularDatasetData\n</code></pre> Source code in <code>siapy/datasets/schemas.py</code> <pre><code>def reset_index(self) -&gt; \"TabularDatasetData\":\n    return TabularDatasetData(\n        pixels=self.pixels.reset_index(drop=True),\n        signals=self.signals.reset_index(drop=True),\n        metadata=self.metadata.reset_index(drop=True),\n        target=self.target.reset_index() if self.target is not None else None,\n    )\n</code></pre>"},{"location":"api/datasets/tabular/","title":"Tabular","text":""},{"location":"api/datasets/tabular/#siapy.datasets.tabular","title":"siapy.datasets.tabular","text":""},{"location":"api/datasets/tabular/#siapy.datasets.tabular.MetaDataEntity","title":"MetaDataEntity","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.MetaDataEntity.image_idx","title":"image_idx  <code>instance-attribute</code>","text":"<pre><code>image_idx: int\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.MetaDataEntity.image_filepath","title":"image_filepath  <code>instance-attribute</code>","text":"<pre><code>image_filepath: Path\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.MetaDataEntity.camera_id","title":"camera_id  <code>instance-attribute</code>","text":"<pre><code>camera_id: str\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.MetaDataEntity.shape_idx","title":"shape_idx  <code>instance-attribute</code>","text":"<pre><code>shape_idx: int\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.MetaDataEntity.shape_type","title":"shape_type  <code>instance-attribute</code>","text":"<pre><code>shape_type: str\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.MetaDataEntity.shape_label","title":"shape_label  <code>instance-attribute</code>","text":"<pre><code>shape_label: str | None\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.MetaDataEntity.geometry_idx","title":"geometry_idx  <code>instance-attribute</code>","text":"<pre><code>geometry_idx: int\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataEntity","title":"TabularDataEntity","text":"<p>               Bases: <code>MetaDataEntity</code></p>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataEntity.image_idx","title":"image_idx  <code>instance-attribute</code>","text":"<pre><code>image_idx: int\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataEntity.image_filepath","title":"image_filepath  <code>instance-attribute</code>","text":"<pre><code>image_filepath: Path\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataEntity.camera_id","title":"camera_id  <code>instance-attribute</code>","text":"<pre><code>camera_id: str\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataEntity.shape_idx","title":"shape_idx  <code>instance-attribute</code>","text":"<pre><code>shape_idx: int\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataEntity.shape_type","title":"shape_type  <code>instance-attribute</code>","text":"<pre><code>shape_type: str\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataEntity.shape_label","title":"shape_label  <code>instance-attribute</code>","text":"<pre><code>shape_label: str | None\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataEntity.geometry_idx","title":"geometry_idx  <code>instance-attribute</code>","text":"<pre><code>geometry_idx: int\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataEntity.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataEntity.signatures","title":"signatures  <code>instance-attribute</code>","text":"<pre><code>signatures: Signatures\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataset","title":"TabularDataset  <code>dataclass</code>","text":"<pre><code>TabularDataset(container: ImageContainerType)\n</code></pre> Source code in <code>siapy/datasets/tabular.py</code> <pre><code>def __init__(self, container: ImageContainerType):\n    self._image_set = SpectralImageSet([container]) if isinstance(container, SpectralImage) else container\n    self._data_entities: list[TabularDataEntity] = []\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataset.image_set","title":"image_set  <code>property</code>","text":"<pre><code>image_set: SpectralImageSet\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataset.data_entities","title":"data_entities  <code>property</code>","text":"<pre><code>data_entities: list[TabularDataEntity]\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataset.process_image_data","title":"process_image_data","text":"<pre><code>process_image_data()\n</code></pre> Source code in <code>siapy/datasets/tabular.py</code> <pre><code>def process_image_data(self):\n    self.data_entities.clear()\n    for image_idx, image in enumerate(self.image_set):\n        for shape_idx, shape in enumerate(image.geometric_shapes.shapes):\n            convex_hulls = shape.get_pixels_within_convex_hull()\n            for geometry_idx, pixels in enumerate(convex_hulls):\n                signatures = image.to_signatures(pixels)\n                entity = TabularDataEntity(\n                    image_idx=image_idx,\n                    shape_idx=shape_idx,\n                    geometry_idx=geometry_idx,\n                    image_filepath=image.filepath,\n                    camera_id=image.camera_id,\n                    shape_type=shape.shape_type,\n                    shape_label=shape.label,\n                    signatures=signatures,\n                )\n                self.data_entities.append(entity)\n</code></pre>"},{"location":"api/datasets/tabular/#siapy.datasets.tabular.TabularDataset.generate_dataset_data","title":"generate_dataset_data","text":"<pre><code>generate_dataset_data(mean_signatures=True) -&gt; TabularDatasetData\n</code></pre> Source code in <code>siapy/datasets/tabular.py</code> <pre><code>def generate_dataset_data(self, mean_signatures=True) -&gt; TabularDatasetData:\n    self._check_data_entities()\n    pixels_dfs = []\n    signals_dfs = []\n    metadata_dfs = []\n    for entity in self.data_entities:\n        signatures_df = entity.signatures.to_dataframe().dropna()\n        if mean_signatures:\n            signatures_df = signatures_df.mean().to_frame().T\n\n        signatures_len = len(signatures_df)\n        metadata_df = pd.DataFrame(\n            {\n                \"image_idx\": [str(entity.image_idx)] * signatures_len,\n                \"image_filepath\": [str(entity.image_filepath)] * signatures_len,\n                \"camera_id\": [entity.camera_id] * signatures_len,\n                \"shape_idx\": [str(entity.shape_idx)] * signatures_len,\n                \"shape_type\": [entity.shape_type] * signatures_len,\n                \"shape_label\": [entity.shape_label] * signatures_len,\n                \"geometry_idx\": [str(entity.geometry_idx)] * signatures_len,\n            }\n        )\n\n        assert list(metadata_df.columns) == list(MetaDataEntity.model_fields.keys()), (\n            \"Sanity check failed! The columns in metadata_df do not match MetaDataEntity fields.\"\n        )\n\n        signatures = Signatures.from_dataframe(signatures_df)\n\n        pixels_dfs.append(signatures.pixels.df)\n        signals_dfs.append(signatures.signals.df)\n        metadata_dfs.append(metadata_df)\n\n    return TabularDatasetData(\n        pixels=pd.concat(pixels_dfs, ignore_index=True),\n        signals=pd.concat(signals_dfs, ignore_index=True),\n        metadata=pd.concat(metadata_dfs, ignore_index=True),\n    )\n</code></pre>"},{"location":"api/entities/imagesets/","title":"Image Sets","text":""},{"location":"api/entities/imagesets/#siapy.entities.imagesets","title":"siapy.entities.imagesets","text":""},{"location":"api/entities/imagesets/#siapy.entities.imagesets.SpectralImageSet","title":"SpectralImageSet  <code>dataclass</code>","text":"<pre><code>SpectralImageSet(spectral_images: list[SpectralImage] | None = None)\n</code></pre> Source code in <code>siapy/entities/imagesets.py</code> <pre><code>def __init__(self, spectral_images: list[SpectralImage] | None = None):\n    self._images = spectral_images if spectral_images is not None else []\n</code></pre>"},{"location":"api/entities/imagesets/#siapy.entities.imagesets.SpectralImageSet.images","title":"images  <code>property</code>","text":"<pre><code>images: list[SpectralImage]\n</code></pre>"},{"location":"api/entities/imagesets/#siapy.entities.imagesets.SpectralImageSet.cameras_id","title":"cameras_id  <code>property</code>","text":"<pre><code>cameras_id: list[str]\n</code></pre>"},{"location":"api/entities/imagesets/#siapy.entities.imagesets.SpectralImageSet.spy_open","title":"spy_open  <code>classmethod</code>","text":"<pre><code>spy_open(*, header_paths: Sequence[str | Path], image_paths: Sequence[str | Path] | None = None)\n</code></pre> Source code in <code>siapy/entities/imagesets.py</code> <pre><code>@classmethod\ndef spy_open(\n    cls,\n    *,\n    header_paths: Sequence[str | Path],\n    image_paths: Sequence[str | Path] | None = None,\n):\n    if image_paths is not None and len(header_paths) != len(image_paths):\n        raise InvalidInputError(\n            {\n                \"header_paths_length\": len(header_paths),\n                \"image_paths_length\": len(image_paths),\n            },\n            \"The length of hdr_paths and img_path must be equal.\",\n        )\n\n    if image_paths is None:\n        spectral_images = [\n            SpectralImage.spy_open(header_path=hdr_path)\n            for hdr_path in track(header_paths, description=\"Loading spectral images...\")\n        ]\n    else:\n        spectral_images = [\n            SpectralImage.spy_open(header_path=hdr_path, image_path=img_path)\n            for hdr_path, img_path in track(\n                zip(header_paths, image_paths),\n                description=\"Loading spectral images...\",\n            )\n        ]\n    logger.info(\"Spectral images loaded into memory.\")\n    return cls(spectral_images)\n</code></pre>"},{"location":"api/entities/imagesets/#siapy.entities.imagesets.SpectralImageSet.rasterio_open","title":"rasterio_open  <code>classmethod</code>","text":"<pre><code>rasterio_open(*, filepaths: Sequence[str | Path])\n</code></pre> Source code in <code>siapy/entities/imagesets.py</code> <pre><code>@classmethod\ndef rasterio_open(\n    cls,\n    *,\n    filepaths: Sequence[str | Path],\n):\n    spectral_images = [\n        SpectralImage.rasterio_open(filepath)\n        for filepath in track(filepaths, description=\"Loading raster images...\")\n    ]\n    logger.info(\"Raster images loaded into memory.\")\n    return cls(spectral_images)\n</code></pre>"},{"location":"api/entities/imagesets/#siapy.entities.imagesets.SpectralImageSet.images_by_camera_id","title":"images_by_camera_id","text":"<pre><code>images_by_camera_id(camera_id: str)\n</code></pre> Source code in <code>siapy/entities/imagesets.py</code> <pre><code>def images_by_camera_id(self, camera_id: str):\n    ids = np.array([image.camera_id for image in self.images])\n    indices = np.nonzero(ids == camera_id)[0]\n    return [image for idx, image in enumerate(self.images) if idx in indices]\n</code></pre>"},{"location":"api/entities/imagesets/#siapy.entities.imagesets.SpectralImageSet.sort","title":"sort","text":"<pre><code>sort(key: Any = None, reverse: bool = False)\n</code></pre> Source code in <code>siapy/entities/imagesets.py</code> <pre><code>def sort(self, key: Any = None, reverse: bool = False):\n    self.images.sort(key=key, reverse=reverse)\n</code></pre>"},{"location":"api/entities/pixels/","title":"Pixels","text":""},{"location":"api/entities/pixels/#siapy.entities.pixels","title":"siapy.entities.pixels","text":""},{"location":"api/entities/pixels/#siapy.entities.pixels.CoordinateInput","title":"CoordinateInput  <code>module-attribute</code>","text":"<pre><code>CoordinateInput: TypeAlias = PixelCoordinate | tuple[float, float] | Sequence[float]\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.HomogeneousCoordinate","title":"HomogeneousCoordinate  <code>dataclass</code>","text":"<pre><code>HomogeneousCoordinate(X: str = 'x', Y: str = 'y', H: str = 'h')\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.HomogeneousCoordinate.X","title":"X  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>X: str = 'x'\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.HomogeneousCoordinate.Y","title":"Y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Y: str = 'y'\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.HomogeneousCoordinate.H","title":"H  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>H: str = 'h'\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.PixelCoordinate","title":"PixelCoordinate","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"api/entities/pixels/#siapy.entities.pixels.PixelCoordinate.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x: float\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.PixelCoordinate.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y: float\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels","title":"Pixels  <code>dataclass</code>","text":"<pre><code>Pixels(_data: DataFrame)\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels.coords","title":"coords  <code>class-attribute</code>","text":"<pre><code>coords: HomogeneousCoordinate = HomogeneousCoordinate()\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels.df","title":"df  <code>property</code>","text":"<pre><code>df: DataFrame\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(iterable: Iterable[CoordinateInput]) -&gt; Pixels\n</code></pre> Source code in <code>siapy/entities/pixels.py</code> <pre><code>@classmethod\ndef from_iterable(cls, iterable: Iterable[CoordinateInput]) -&gt; \"Pixels\":\n    df = pd.DataFrame(iterable, columns=[cls.coords.X, cls.coords.Y])\n    validate_pixel_input_dimensions(df)\n    return cls(df)\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels.load_from_parquet","title":"load_from_parquet  <code>classmethod</code>","text":"<pre><code>load_from_parquet(filepath: str | Path) -&gt; Pixels\n</code></pre> Source code in <code>siapy/entities/pixels.py</code> <pre><code>@classmethod\ndef load_from_parquet(cls, filepath: str | Path) -&gt; \"Pixels\":\n    df = pd.read_parquet(filepath)\n    validate_pixel_input_dimensions(df)\n    return cls(df)\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels.df_homogenious","title":"df_homogenious","text":"<pre><code>df_homogenious() -&gt; DataFrame\n</code></pre> Source code in <code>siapy/entities/pixels.py</code> <pre><code>def df_homogenious(self) -&gt; pd.DataFrame:\n    df_homo = self.df.copy()\n    df_homo[self.coords.H] = 1\n    return df_homo\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels.u","title":"u","text":"<pre><code>u() -&gt; Series\n</code></pre> Source code in <code>siapy/entities/pixels.py</code> <pre><code>def u(self) -&gt; pd.Series:\n    return self.df[self.coords.X]\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels.v","title":"v","text":"<pre><code>v() -&gt; Series\n</code></pre> Source code in <code>siapy/entities/pixels.py</code> <pre><code>def v(self) -&gt; pd.Series:\n    return self.df[self.coords.Y]\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; ndarray\n</code></pre> Source code in <code>siapy/entities/pixels.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n    return self.df.to_numpy()\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels.to_list","title":"to_list","text":"<pre><code>to_list() -&gt; list[PixelCoordinate]\n</code></pre> Source code in <code>siapy/entities/pixels.py</code> <pre><code>def to_list(self) -&gt; list[PixelCoordinate]:\n    return self.df.values.tolist()\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels.save_to_parquet","title":"save_to_parquet","text":"<pre><code>save_to_parquet(filepath: str | Path) -&gt; None\n</code></pre> Source code in <code>siapy/entities/pixels.py</code> <pre><code>def save_to_parquet(self, filepath: str | Path) -&gt; None:\n    self.df.to_parquet(filepath, index=True)\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.Pixels.as_type","title":"as_type","text":"<pre><code>as_type(dtype: type) -&gt; Pixels\n</code></pre> Source code in <code>siapy/entities/pixels.py</code> <pre><code>def as_type(self, dtype: type) -&gt; \"Pixels\":\n    converted_df = self.df.copy()\n    converted_df[self.coords.X] = converted_df[self.coords.X].astype(dtype)\n    converted_df[self.coords.Y] = converted_df[self.coords.Y].astype(dtype)\n    return Pixels(converted_df)\n</code></pre>"},{"location":"api/entities/pixels/#siapy.entities.pixels.validate_pixel_input_dimensions","title":"validate_pixel_input_dimensions","text":"<pre><code>validate_pixel_input_dimensions(df: DataFrame)\n</code></pre> Source code in <code>siapy/entities/pixels.py</code> <pre><code>def validate_pixel_input_dimensions(df: pd.DataFrame):\n    if df.shape[1] != 2:\n        raise InvalidInputError(\n            message=\"Invalid input dimensions: expected 2 columns (u, v), got\",\n            input_value=df.shape[1],\n        )\n    if sorted(df.columns) != sorted([HomogeneousCoordinate.X, HomogeneousCoordinate.Y]):\n        raise InvalidInputError(\n            message=f\"Invalid column names: expected ['{HomogeneousCoordinate.X}', '{HomogeneousCoordinate.Y}'], got\",\n            input_value=sorted(df.columns),\n        )\n</code></pre>"},{"location":"api/entities/signatures/","title":"Signatures","text":""},{"location":"api/entities/signatures/#siapy.entities.signatures","title":"siapy.entities.signatures","text":""},{"location":"api/entities/signatures/#siapy.entities.signatures.Signals","title":"Signals  <code>dataclass</code>","text":"<pre><code>Signals(_data: DataFrame)\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signals.df","title":"df  <code>property</code>","text":"<pre><code>df: DataFrame\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signals.load_from_parquet","title":"load_from_parquet  <code>classmethod</code>","text":"<pre><code>load_from_parquet(filepath: str | Path) -&gt; Signals\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>@classmethod\ndef load_from_parquet(cls, filepath: str | Path) -&gt; \"Signals\":\n    df = pd.read_parquet(filepath)\n    return cls(df)\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signals.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; ndarray\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n    return self.df.to_numpy()\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signals.mean","title":"mean","text":"<pre><code>mean() -&gt; ndarray\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>def mean(self) -&gt; np.ndarray:\n    return np.nanmean(self.to_numpy(), axis=0)\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signals.save_to_parquet","title":"save_to_parquet","text":"<pre><code>save_to_parquet(filepath: str | Path) -&gt; None\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>def save_to_parquet(self, filepath: str | Path) -&gt; None:\n    self.df.to_parquet(filepath, index=True)\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signatures","title":"Signatures  <code>dataclass</code>","text":"<pre><code>Signatures(_pixels: Pixels, _signals: Signals)\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signatures.pixels","title":"pixels  <code>property</code>","text":"<pre><code>pixels: Pixels\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signatures.signals","title":"signals  <code>property</code>","text":"<pre><code>signals: Signals\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signatures.from_array_and_pixels","title":"from_array_and_pixels  <code>classmethod</code>","text":"<pre><code>from_array_and_pixels(image: ndarray, pixels: Pixels) -&gt; Signatures\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>@classmethod\ndef from_array_and_pixels(cls, image: np.ndarray, pixels: Pixels) -&gt; \"Signatures\":\n    pixels = pixels.as_type(int)\n    u = pixels.u()\n    v = pixels.v()\n\n    if image.ndim != 3:\n        raise InvalidInputError(f\"Expected a 3-dimensional array, but got {image.ndim}-dimensional array.\")\n    if np.max(u) &gt;= image.shape[1] or np.max(v) &gt;= image.shape[0]:\n        raise InvalidInputError(\n            f\"Pixel coordinates exceed image dimensions: \"\n            f\"image shape is {image.shape}, but max u={np.max(u)}, max v={np.max(v)}.\"\n        )\n\n    signals_list = image[v, u, :]\n    signals = Signals(pd.DataFrame(signals_list))\n    return cls(pixels, signals)\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signatures.from_dataframe","title":"from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(dataframe: DataFrame) -&gt; Signatures\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>@classmethod\ndef from_dataframe(cls, dataframe: pd.DataFrame) -&gt; \"Signatures\":\n    if not all(coord in dataframe.columns for coord in [Pixels.coords.X, Pixels.coords.Y]):\n        raise InvalidInputError(\n            dataframe.columns.tolist(),\n            f\"DataFrame must include columns for both '{Pixels.coords.X}' and '{Pixels.coords.Y}' coordinates.\",\n        )\n    pixels = Pixels(dataframe[[Pixels.coords.X, Pixels.coords.Y]])\n    signals = Signals(dataframe.drop(columns=[Pixels.coords.X, Pixels.coords.Y]))\n    return cls(pixels, signals)\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signatures.from_dataframe_multiindex","title":"from_dataframe_multiindex  <code>classmethod</code>","text":"<pre><code>from_dataframe_multiindex(df: DataFrame) -&gt; Signatures\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>@classmethod\ndef from_dataframe_multiindex(cls, df: pd.DataFrame) -&gt; \"Signatures\":\n    if not isinstance(df.columns, pd.MultiIndex):\n        raise InvalidInputError(\n            type(df.columns),\n            \"DataFrame must have MultiIndex columns\",\n        )\n\n    pixel_data = df.xs(\"pixel\", axis=1, level=\"category\")\n    signal_data = df.xs(\"signal\", axis=1, level=\"category\")\n\n    assert isinstance(pixel_data, pd.DataFrame)\n    assert isinstance(signal_data, pd.DataFrame)\n\n    pixels = Pixels(pixel_data)\n    signals = Signals(signal_data)\n\n    return cls(pixels, signals)\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signatures.open_parquet","title":"open_parquet  <code>classmethod</code>","text":"<pre><code>open_parquet(filepath: str | Path) -&gt; Signatures\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>@classmethod\ndef open_parquet(cls, filepath: str | Path) -&gt; \"Signatures\":\n    df = pd.read_parquet(filepath)\n    return cls.from_dataframe(df)\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signatures.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe() -&gt; DataFrame\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>def to_dataframe(self) -&gt; pd.DataFrame:\n    return pd.concat([self.pixels.df, self.signals.df], axis=1)\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signatures.to_dataframe_multiindex","title":"to_dataframe_multiindex","text":"<pre><code>to_dataframe_multiindex() -&gt; DataFrame\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>def to_dataframe_multiindex(self) -&gt; pd.DataFrame:\n    pixel_columns = pd.MultiIndex.from_tuples(\n        [(\"pixel\", \"x\"), (\"pixel\", \"y\")],\n        names=[\"category\", \"coordinate\"],\n    )\n    signal_columns = pd.MultiIndex.from_tuples(\n        [(\"signal\", col) for col in self.signals.df.columns],\n        names=[\"category\", \"channel\"],\n    )\n\n    pixel_df = pd.DataFrame(self.pixels.df.values, columns=pixel_columns)\n    signal_df = pd.DataFrame(self.signals.df.values, columns=signal_columns)\n    return pd.concat([pixel_df, signal_df], axis=1)\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signatures.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; ndarray\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n    return self.to_dataframe().to_numpy()\n</code></pre>"},{"location":"api/entities/signatures/#siapy.entities.signatures.Signatures.save_to_parquet","title":"save_to_parquet","text":"<pre><code>save_to_parquet(filepath: str | Path) -&gt; None\n</code></pre> Source code in <code>siapy/entities/signatures.py</code> <pre><code>def save_to_parquet(self, filepath: str | Path) -&gt; None:\n    self.to_dataframe().to_parquet(filepath, index=True)\n</code></pre>"},{"location":"api/entities/images/interfaces/","title":"Interfaces","text":""},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces","title":"siapy.entities.images.interfaces","text":""},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase","title":"ImageBase","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase.filepath","title":"filepath  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>filepath: Path\n</code></pre>"},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase.metadata","title":"metadata  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>metadata: dict[str, Any]\n</code></pre>"},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase.shape","title":"shape  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>shape: tuple[int, int, int]\n</code></pre>"},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase.bands","title":"bands  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>bands: int\n</code></pre>"},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase.default_bands","title":"default_bands  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>default_bands: list[int]\n</code></pre>"},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase.wavelengths","title":"wavelengths  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>wavelengths: list[float]\n</code></pre>"},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase.camera_id","title":"camera_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>camera_id: str\n</code></pre>"},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase.open","title":"open  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>open(*args: Any, **kwargs: Any) -&gt; ImageBase\n</code></pre> Source code in <code>siapy/entities/images/interfaces.py</code> <pre><code>@classmethod\n@abstractmethod\ndef open(cls: type[\"ImageBase\"], *args: Any, **kwargs: Any) -&gt; \"ImageBase\":\n    pass\n</code></pre>"},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase.to_display","title":"to_display  <code>abstractmethod</code>","text":"<pre><code>to_display(equalize: bool = True) -&gt; Image\n</code></pre> Source code in <code>siapy/entities/images/interfaces.py</code> <pre><code>@abstractmethod\ndef to_display(self, equalize: bool = True) -&gt; Image.Image:\n    pass\n</code></pre>"},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase.to_numpy","title":"to_numpy  <code>abstractmethod</code>","text":"<pre><code>to_numpy(nan_value: float | None = None) -&gt; ndarray\n</code></pre> Source code in <code>siapy/entities/images/interfaces.py</code> <pre><code>@abstractmethod\ndef to_numpy(self, nan_value: float | None = None) -&gt; np.ndarray:\n    pass\n</code></pre>"},{"location":"api/entities/images/interfaces/#siapy.entities.images.interfaces.ImageBase.to_xarray","title":"to_xarray  <code>abstractmethod</code>","text":"<pre><code>to_xarray() -&gt; XarrayType\n</code></pre> Source code in <code>siapy/entities/images/interfaces.py</code> <pre><code>@abstractmethod\ndef to_xarray(self) -&gt; \"XarrayType\":\n    pass\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/","title":"Rasterio Library","text":""},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib","title":"siapy.entities.images.rasterio_lib","text":""},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage","title":"RasterioLibImage  <code>dataclass</code>","text":"<pre><code>RasterioLibImage(file: XarrayType)\n</code></pre> <p>               Bases: <code>ImageBase</code></p> Source code in <code>siapy/entities/images/rasterio_lib.py</code> <pre><code>def __init__(self, file: \"XarrayType\"):\n    self._file = file\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.file","title":"file  <code>property</code>","text":"<pre><code>file: XarrayType\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: dict[str, Any]\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, int, int]\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: int\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.cols","title":"cols  <code>property</code>","text":"<pre><code>cols: int\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.bands","title":"bands  <code>property</code>","text":"<pre><code>bands: int\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.default_bands","title":"default_bands  <code>property</code>","text":"<pre><code>default_bands: list[int]\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.wavelengths","title":"wavelengths  <code>property</code>","text":"<pre><code>wavelengths: list[float]\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.camera_id","title":"camera_id  <code>property</code>","text":"<pre><code>camera_id: str\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.open","title":"open  <code>classmethod</code>","text":"<pre><code>open(filepath: str | Path) -&gt; RasterioLibImage\n</code></pre> Source code in <code>siapy/entities/images/rasterio_lib.py</code> <pre><code>@classmethod\ndef open(cls, filepath: str | Path) -&gt; \"RasterioLibImage\":\n    filepath = Path(filepath)\n    if not filepath.exists():\n        raise InvalidFilepathError(filepath)\n\n    try:\n        raster = rioxarray.open_rasterio(filepath)\n    except Exception as e:\n        raise InvalidInputError({\"filepath\": str(filepath)}, f\"Failed to open raster file: {e}\") from e\n\n    if isinstance(raster, list):\n        raise InvalidInputError({\"file_type\": type(raster).__name__}, \"Expected DataArray or Dataset, got list\")\n\n    return cls(raster)\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.to_display","title":"to_display","text":"<pre><code>to_display(equalize: bool = True) -&gt; Image\n</code></pre> Source code in <code>siapy/entities/images/rasterio_lib.py</code> <pre><code>def to_display(self, equalize: bool = True) -&gt; Image.Image:\n    bands_data = self.file.sel(band=self.default_bands)\n    image_3ch = bands_data.transpose(\"y\", \"x\", \"band\").values\n    image_3ch_clean = np.nan_to_num(np.asarray(image_3ch))\n    min_val = np.nanmin(image_3ch_clean)\n    max_val = np.nanmax(image_3ch_clean)\n\n    image_scaled = ((image_3ch_clean - min_val) * (255.0 / (max_val - min_val))).astype(np.uint8)\n\n    image = Image.fromarray(image_scaled)\n    if equalize:\n        image = ImageOps.equalize(image)\n    return image\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy(nan_value: float | None = None) -&gt; ndarray\n</code></pre> Source code in <code>siapy/entities/images/rasterio_lib.py</code> <pre><code>def to_numpy(self, nan_value: float | None = None) -&gt; np.ndarray:\n    image = np.asarray(self.file.transpose(\"y\", \"x\", \"band\").values)\n    if nan_value is not None:\n        image = np.nan_to_num(image, nan=nan_value)\n    return image\n</code></pre>"},{"location":"api/entities/images/rasterio_lib/#siapy.entities.images.rasterio_lib.RasterioLibImage.to_xarray","title":"to_xarray","text":"<pre><code>to_xarray() -&gt; XarrayType\n</code></pre> Source code in <code>siapy/entities/images/rasterio_lib.py</code> <pre><code>def to_xarray(self) -&gt; \"XarrayType\":\n    return self.file\n</code></pre>"},{"location":"api/entities/images/spectral_lib/","title":"Spectral Library","text":""},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib","title":"siapy.entities.images.spectral_lib","text":""},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage","title":"SpectralLibImage  <code>dataclass</code>","text":"<pre><code>SpectralLibImage(file: SpectralLibType)\n</code></pre> <p>               Bases: <code>ImageBase</code></p> Source code in <code>siapy/entities/images/spectral_lib.py</code> <pre><code>def __init__(\n    self,\n    file: \"SpectralLibType\",\n):\n    self._file = file\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.file","title":"file  <code>property</code>","text":"<pre><code>file: SpectralLibType\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: dict[str, Any]\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, int, int]\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: int\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.cols","title":"cols  <code>property</code>","text":"<pre><code>cols: int\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.bands","title":"bands  <code>property</code>","text":"<pre><code>bands: int\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.default_bands","title":"default_bands  <code>property</code>","text":"<pre><code>default_bands: list[int]\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.wavelengths","title":"wavelengths  <code>property</code>","text":"<pre><code>wavelengths: list[float]\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.description","title":"description  <code>property</code>","text":"<pre><code>description: dict[str, Any]\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.camera_id","title":"camera_id  <code>property</code>","text":"<pre><code>camera_id: str\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.open","title":"open  <code>classmethod</code>","text":"<pre><code>open(*, header_path: str | Path, image_path: str | Path | None = None) -&gt; SpectralLibImage\n</code></pre> Source code in <code>siapy/entities/images/spectral_lib.py</code> <pre><code>@classmethod\ndef open(cls, *, header_path: str | Path, image_path: str | Path | None = None) -&gt; \"SpectralLibImage\":\n    header_path = Path(header_path)\n    if not header_path.exists():\n        raise InvalidFilepathError(header_path)\n\n    try:\n        sp_file = sp.envi.open(file=header_path, image=image_path)\n    except Exception as e:\n        raise InvalidInputError({\"filepath\": str(header_path)}, f\"Failed to open spectral file: {e}\") from e\n\n    if isinstance(sp_file, sp.io.envi.SpectralLibrary):\n        raise InvalidInputError({\"file_type\": type(sp_file).__name__}, \"Expected Image, got SpectralLibrary\")\n\n    return cls(sp_file)\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.to_display","title":"to_display","text":"<pre><code>to_display(equalize: bool = True) -&gt; Image\n</code></pre> Source code in <code>siapy/entities/images/spectral_lib.py</code> <pre><code>def to_display(self, equalize: bool = True) -&gt; Image.Image:\n    max_uint8 = 255.0\n    image_3ch = self.file.read_bands(self.default_bands)\n    image_3ch = self._remove_nan(image_3ch, nan_value=0)\n    image_3ch[:, :, 0] = image_3ch[:, :, 0] / image_3ch[:, :, 0].max() / max_uint8\n    image_3ch[:, :, 1] = image_3ch[:, :, 1] / (image_3ch[:, :, 1].max() / max_uint8)\n    image_3ch[:, :, 2] = image_3ch[:, :, 2] / (image_3ch[:, :, 2].max() / max_uint8)\n    image = Image.fromarray(image_3ch.astype(\"uint8\"))\n    if equalize:\n        image = ImageOps.equalize(image)\n    return image\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy(nan_value: float | None = None) -&gt; ndarray\n</code></pre> Source code in <code>siapy/entities/images/spectral_lib.py</code> <pre><code>def to_numpy(self, nan_value: float | None = None) -&gt; np.ndarray:\n    image = self.file[:, :, :]\n    if nan_value is not None:\n        image = self._remove_nan(image, nan_value)\n    return image\n</code></pre>"},{"location":"api/entities/images/spectral_lib/#siapy.entities.images.spectral_lib.SpectralLibImage.to_xarray","title":"to_xarray","text":"<pre><code>to_xarray() -&gt; XarrayType\n</code></pre> Source code in <code>siapy/entities/images/spectral_lib.py</code> <pre><code>def to_xarray(self) -&gt; \"XarrayType\":\n    data = self._file[:, :, :]\n    xarray = xr.DataArray(\n        data,\n        dims=[\"y\", \"x\", \"band\"],\n        coords={\n            \"y\": np.arange(self.rows),\n            \"x\": np.arange(self.cols),\n            \"band\": self.wavelengths,\n        },\n        attrs=self._file.metadata,\n    )\n    return xarray\n</code></pre>"},{"location":"api/entities/images/spimage/","title":"Spectral Images","text":""},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage","title":"siapy.entities.images.spimage","text":""},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=ImageBase)\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage","title":"SpectralImage  <code>dataclass</code>","text":"<pre><code>SpectralImage(image: T, geometric_shapes: list[Shape] | None = None)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> Source code in <code>siapy/entities/images/spimage.py</code> <pre><code>def __init__(\n    self,\n    image: T,\n    geometric_shapes: list[\"Shape\"] | None = None,\n):\n    self._image = image\n    self._geometric_shapes = GeometricShapes(self, geometric_shapes)\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.image","title":"image  <code>property</code>","text":"<pre><code>image: T\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.geometric_shapes","title":"geometric_shapes  <code>property</code>","text":"<pre><code>geometric_shapes: GeometricShapes\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: dict[str, Any]\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, int, int]\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.bands","title":"bands  <code>property</code>","text":"<pre><code>bands: int\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.default_bands","title":"default_bands  <code>property</code>","text":"<pre><code>default_bands: list[int]\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.wavelengths","title":"wavelengths  <code>property</code>","text":"<pre><code>wavelengths: list[float]\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.camera_id","title":"camera_id  <code>property</code>","text":"<pre><code>camera_id: str\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.spy_open","title":"spy_open  <code>classmethod</code>","text":"<pre><code>spy_open(*, header_path: str | Path, image_path: str | Path | None = None) -&gt; SpectralImage[SpectralLibImage]\n</code></pre> Source code in <code>siapy/entities/images/spimage.py</code> <pre><code>@classmethod\ndef spy_open(\n    cls, *, header_path: str | Path, image_path: str | Path | None = None\n) -&gt; \"SpectralImage[SpectralLibImage]\":\n    image = SpectralLibImage.open(header_path=header_path, image_path=image_path)\n    return SpectralImage(image)\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.rasterio_open","title":"rasterio_open  <code>classmethod</code>","text":"<pre><code>rasterio_open(filepath: str | Path) -&gt; SpectralImage[RasterioLibImage]\n</code></pre> Source code in <code>siapy/entities/images/spimage.py</code> <pre><code>@classmethod\ndef rasterio_open(cls, filepath: str | Path) -&gt; \"SpectralImage[RasterioLibImage]\":\n    image = RasterioLibImage.open(filepath)\n    return SpectralImage(image)\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.to_display","title":"to_display","text":"<pre><code>to_display(equalize: bool = True) -&gt; Image\n</code></pre> Source code in <code>siapy/entities/images/spimage.py</code> <pre><code>def to_display(self, equalize: bool = True) -&gt; Image.Image:\n    return self.image.to_display(equalize)\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy(nan_value: float | None = None) -&gt; ndarray\n</code></pre> Source code in <code>siapy/entities/images/spimage.py</code> <pre><code>def to_numpy(self, nan_value: float | None = None) -&gt; np.ndarray:\n    return self.image.to_numpy(nan_value)\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.to_xarray","title":"to_xarray","text":"<pre><code>to_xarray() -&gt; XarrayType\n</code></pre> Source code in <code>siapy/entities/images/spimage.py</code> <pre><code>def to_xarray(self) -&gt; \"XarrayType\":\n    return self.image.to_xarray()\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.to_signatures","title":"to_signatures","text":"<pre><code>to_signatures(pixels: Pixels) -&gt; Signatures\n</code></pre> Source code in <code>siapy/entities/images/spimage.py</code> <pre><code>def to_signatures(self, pixels: \"Pixels\") -&gt; Signatures:\n    image_arr = self.to_numpy()\n    signatures = Signatures.from_array_and_pixels(image_arr, pixels)\n    return signatures\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.to_subarray","title":"to_subarray","text":"<pre><code>to_subarray(pixels: Pixels) -&gt; ndarray\n</code></pre> Source code in <code>siapy/entities/images/spimage.py</code> <pre><code>def to_subarray(self, pixels: \"Pixels\") -&gt; np.ndarray:\n    image_arr = self.to_numpy()\n    u_max = pixels.u().max()\n    u_min = pixels.u().min()\n    v_max = pixels.v().max()\n    v_min = pixels.v().min()\n    # create new image\n    image_arr_area = np.nan * np.ones((v_max - v_min + 1, u_max - u_min + 1, self.bands))\n    # convert original coordinates to coordinates for new image\n    v_norm = pixels.v() - v_min\n    u_norm = pixels.u() - u_min\n    # write values from original image to new image\n    image_arr_area[v_norm, u_norm, :] = image_arr[pixels.v(), pixels.u(), :]\n    return image_arr_area\n</code></pre>"},{"location":"api/entities/images/spimage/#siapy.entities.images.spimage.SpectralImage.mean","title":"mean","text":"<pre><code>mean(axis: int | tuple[int, ...] | Sequence[int] | None = None) -&gt; float | ndarray\n</code></pre> Source code in <code>siapy/entities/images/spimage.py</code> <pre><code>def mean(self, axis: int | tuple[int, ...] | Sequence[int] | None = None) -&gt; float | np.ndarray:\n    image_arr = self.to_numpy()\n    return np.nanmean(image_arr, axis=axis)\n</code></pre>"},{"location":"api/entities/shapes/shape/","title":"Shape","text":""},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape","title":"siapy.entities.shapes.shape","text":""},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.ShapeGeometryEnum","title":"ShapeGeometryEnum","text":"<p>               Bases: <code>Enum</code></p> <p>Geometry Types: - Point: Single coordinate point (x,y) - LineString: Series of connected points forming a line - Polygon: Closed shape with interior area - MultiPoint: Collection of independent points - MultiLineString: Collection of independent lines - MultiPolygon: Collection of independent polygons</p>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.ShapeGeometryEnum.POINT","title":"POINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POINT = 'point'\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.ShapeGeometryEnum.LINE","title":"LINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LINE = 'linestring'\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.ShapeGeometryEnum.POLYGON","title":"POLYGON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POLYGON = 'polygon'\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.ShapeGeometryEnum.MULTIPOINT","title":"MULTIPOINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MULTIPOINT = 'multipoint'\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.ShapeGeometryEnum.MULTILINE","title":"MULTILINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MULTILINE = 'multilinestring'\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.ShapeGeometryEnum.MULTIPOLYGON","title":"MULTIPOLYGON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MULTIPOLYGON = 'multipolygon'\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape","title":"Shape","text":"<pre><code>Shape(label: str = '', geometry: Optional[BaseGeometry] = None, geo_dataframe: Optional[GeoDataFrame] = None)\n</code></pre> <p>Unified shape class that can be created from shapefiles or programmatically.</p> <p>This class uses GeoDataFrame as its primary internal representation. Direct initialization is possible but using class methods is recommended.</p> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>def __init__(\n    self,\n    label: str = \"\",\n    geometry: Optional[BaseGeometry] = None,\n    geo_dataframe: Optional[gpd.GeoDataFrame] = None,\n):\n    \"\"\"Initialize Shape with either a geometry or geodataframe\"\"\"\n    self._label = label\n\n    if geo_dataframe is not None and geometry is not None:\n        raise ConfigurationError(\"Cannot provide both geometry and geodataframe\")\n\n    if geo_dataframe is not None:\n        self._geodataframe = geo_dataframe\n    elif geometry is not None:\n        self._geodataframe = gpd.GeoDataFrame(geometry=[geometry])\n    else:\n        raise ConfigurationError(\"Must provide either geometry or geodataframe\")\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.df","title":"df  <code>property</code>","text":"<pre><code>df: GeoDataFrame\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.label","title":"label  <code>property</code> <code>writable</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.geometry","title":"geometry  <code>property</code> <code>writable</code>","text":"<pre><code>geometry: GeoSeries\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.shape_type","title":"shape_type  <code>property</code>","text":"<pre><code>shape_type: str\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.is_multi","title":"is_multi  <code>property</code>","text":"<pre><code>is_multi: bool\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.is_point","title":"is_point  <code>property</code>","text":"<pre><code>is_point: bool\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.is_line","title":"is_line  <code>property</code>","text":"<pre><code>is_line: bool\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.is_polygon","title":"is_polygon  <code>property</code>","text":"<pre><code>is_polygon: bool\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.boundary","title":"boundary  <code>property</code>","text":"<pre><code>boundary: GeoSeries\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.bounds","title":"bounds  <code>property</code>","text":"<pre><code>bounds: DataFrame\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.centroid","title":"centroid  <code>property</code>","text":"<pre><code>centroid: GeoSeries\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.convex_hull","title":"convex_hull  <code>property</code>","text":"<pre><code>convex_hull: GeoSeries\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.envelope","title":"envelope  <code>property</code>","text":"<pre><code>envelope: GeoSeries\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.exterior","title":"exterior  <code>property</code>","text":"<pre><code>exterior: GeoSeries\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.open_shapefile","title":"open_shapefile  <code>classmethod</code>","text":"<pre><code>open_shapefile(filepath: str | Path, label: str = '') -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>@classmethod\ndef open_shapefile(cls, filepath: str | Path, label: str = \"\") -&gt; \"Shape\":\n    filepath = Path(filepath)\n    if not filepath.exists():\n        raise InvalidFilepathError(filepath)\n    try:\n        geo_df = gpd.read_file(filepath)\n    except Exception as e:\n        raise InvalidInputError({\"filepath\": str(filepath)}, f\"Failed to open shapefile: {e}\") from e\n    return cls(geo_dataframe=geo_df, label=label)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(geometry: BaseGeometry, label: str = '') -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>@classmethod\ndef from_geometry(cls, geometry: BaseGeometry, label: str = \"\") -&gt; \"Shape\":\n    if not isinstance(geometry, BaseGeometry):\n        raise InvalidTypeError(\n            input_value=geometry,\n            allowed_types=BaseGeometry,\n            message=\"Geometry must be of type BaseGeometry\",\n        )\n    return cls(geometry=geometry, label=label)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.from_geodataframe","title":"from_geodataframe  <code>classmethod</code>","text":"<pre><code>from_geodataframe(geo_dataframe: GeoDataFrame, label: str = '') -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>@classmethod\ndef from_geodataframe(cls, geo_dataframe: gpd.GeoDataFrame, label: str = \"\") -&gt; \"Shape\":\n    if not isinstance(geo_dataframe, gpd.GeoDataFrame):\n        raise InvalidTypeError(\n            input_value=geo_dataframe,\n            allowed_types=gpd.GeoDataFrame,\n            message=\"GeoDataFrame must be of type GeoDataFrame\",\n        )\n    return cls(geo_dataframe=geo_dataframe, label=label)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.from_point","title":"from_point  <code>classmethod</code>","text":"<pre><code>from_point(x: float, y: float, label: str = '') -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>@classmethod\ndef from_point(cls, x: float, y: float, label: str = \"\") -&gt; \"Shape\":\n    return cls(geometry=Point(x, y), label=label)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.from_multipoint","title":"from_multipoint  <code>classmethod</code>","text":"<pre><code>from_multipoint(points: Pixels, label: str = '') -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>@classmethod\ndef from_multipoint(cls, points: \"Pixels\", label: str = \"\") -&gt; \"Shape\":\n    if len(points) &lt; 1:\n        raise ConfigurationError(\"At least one point is required\")\n    coords = points.to_list()\n    return cls(geometry=MultiPoint(coords), label=label)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.from_line","title":"from_line  <code>classmethod</code>","text":"<pre><code>from_line(pixels: Pixels, label: str = '') -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>@classmethod\ndef from_line(cls, pixels: Pixels, label: str = \"\") -&gt; \"Shape\":\n    if len(pixels) &lt; 2:\n        raise ConfigurationError(\"At least two points are required for a line\")\n\n    return cls(geometry=LineString(pixels.to_list()), label=label)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.from_multiline","title":"from_multiline  <code>classmethod</code>","text":"<pre><code>from_multiline(line_segments: list[Pixels], label: str = '') -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>@classmethod\ndef from_multiline(cls, line_segments: list[Pixels], label: str = \"\") -&gt; \"Shape\":\n    if not line_segments:\n        raise ConfigurationError(\"At least one line segment is required\")\n\n    lines = [LineString(segment.to_list()) for segment in line_segments]\n    multi_line = MultiLineString(lines)\n    return cls(geometry=multi_line, label=label)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.from_polygon","title":"from_polygon  <code>classmethod</code>","text":"<pre><code>from_polygon(exterior: Pixels, holes: Optional[list[Pixels]] = None, label: str = '') -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>@classmethod\ndef from_polygon(cls, exterior: Pixels, holes: Optional[list[Pixels]] = None, label: str = \"\") -&gt; \"Shape\":\n    if len(exterior) &lt; 3:\n        raise ConfigurationError(\"At least three points are required for a polygon\")\n\n    exterior_coords = exterior.to_list()\n    # Close the polygon if not already closed\n    if exterior_coords[0] != exterior_coords[-1]:\n        exterior_coords.append(exterior_coords[0])\n\n    if holes:\n        # Close each hole if not already closed\n        closed_holes = []\n        for hole in holes:\n            hole_coords = hole.to_list()\n            if hole_coords[0] != hole_coords[-1]:\n                hole_coords.append(hole_coords[0])\n            closed_holes.append(hole_coords)\n        geometry = Polygon(exterior_coords, closed_holes)\n    else:\n        geometry = Polygon(exterior_coords)\n\n    return cls(geometry=geometry, label=label)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.from_multipolygon","title":"from_multipolygon  <code>classmethod</code>","text":"<pre><code>from_multipolygon(polygons: list[Pixels], label: str = '') -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>@classmethod\ndef from_multipolygon(cls, polygons: list[Pixels], label: str = \"\") -&gt; \"Shape\":\n    if not polygons:\n        raise ConfigurationError(\"At least one polygon is required\")\n\n    polygon_objects = []\n    for pixels in polygons:\n        coords = pixels.to_list()\n        # Close the polygon if not already closed\n        if coords[0] != coords[-1]:\n            coords.append(coords[0])\n        polygon_objects.append(Polygon(coords))\n\n    multi_polygon = MultiPolygon(polygon_objects)\n    return cls(geometry=multi_polygon, label=label)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.from_rectangle","title":"from_rectangle  <code>classmethod</code>","text":"<pre><code>from_rectangle(x_min: int, y_min: int, x_max: int, y_max: int, label: str = '') -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>@classmethod\ndef from_rectangle(cls, x_min: int, y_min: int, x_max: int, y_max: int, label: str = \"\") -&gt; \"Shape\":\n    coords = [(x_min, y_min), (x_max, y_min), (x_max, y_max), (x_min, y_max)]\n    return cls(geometry=Polygon(coords), label=label)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.from_circle","title":"from_circle  <code>classmethod</code>","text":"<pre><code>from_circle(center: PixelCoordinate, radius: float, label: str = '') -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>@classmethod\ndef from_circle(cls, center: PixelCoordinate, radius: float, label: str = \"\") -&gt; \"Shape\":\n    point = Point(center)\n    circle = point.buffer(radius)\n    return cls(geometry=circle, label=label)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.copy","title":"copy","text":"<pre><code>copy() -&gt; Shape\n</code></pre> <p>Create a deep copy of the Shape instance.</p> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>def copy(self) -&gt; \"Shape\":\n    \"\"\"Create a deep copy of the Shape instance.\"\"\"\n    copied_df = self.df.copy(deep=True)\n    return Shape(label=self.label, geo_dataframe=copied_df)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.buffer","title":"buffer","text":"<pre><code>buffer(distance: float) -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>def buffer(self, distance: float) -&gt; \"Shape\":\n    buffered_geometry = self.geometry.buffer(distance)\n    result = self.copy()\n    result.geometry = buffered_geometry\n    return result\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.intersection","title":"intersection","text":"<pre><code>intersection(other: Shape) -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>def intersection(self, other: \"Shape\") -&gt; \"Shape\":\n    intersection_geometry = self.geometry.intersection(other.geometry)\n    result = self.copy()\n    result.geometry = intersection_geometry\n    return result\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.union","title":"union","text":"<pre><code>union(other: Shape) -&gt; Shape\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>def union(self, other: \"Shape\") -&gt; \"Shape\":\n    union_geometry = self.geometry.union(other.geometry)\n    result = self.copy()\n    result.geometry = union_geometry\n    return result\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.to_file","title":"to_file","text":"<pre><code>to_file(filepath: str | Path, driver: str = 'ESRI Shapefile') -&gt; None\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>def to_file(self, filepath: str | Path, driver: str = \"ESRI Shapefile\") -&gt; None:\n    self._geodataframe.to_file(filepath, driver=driver)\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; ndarray\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n    return self.df.to_numpy()\n</code></pre>"},{"location":"api/entities/shapes/shape/#siapy.entities.shapes.shape.Shape.get_pixels_within_convex_hull","title":"get_pixels_within_convex_hull","text":"<pre><code>get_pixels_within_convex_hull(resolution: float = 1.0) -&gt; list[Pixels]\n</code></pre> Source code in <code>siapy/entities/shapes/shape.py</code> <pre><code>def get_pixels_within_convex_hull(self, resolution: float = 1.0) -&gt; list[Pixels]:\n    pixels: list[Pixels] = []\n\n    if self.is_point:\n        for g in self.geometry:\n            if isinstance(g, MultiPoint):\n                points = list(g.geoms)\n            elif isinstance(g, Point):\n                points = [g]\n            else:\n                raise InvalidTypeError(\n                    input_value=g,\n                    allowed_types=(Point, MultiPoint),\n                    message=\"Geometry must be Point or MultiPoint\",\n                )\n            pixels.append(Pixels.from_iterable([(p.x, p.y) for p in points]))\n\n        return pixels\n\n    if resolution &lt;= 0:\n        raise InvalidInputError({\"resolution\": resolution}, \"Resolution must be positive\")\n\n    for hull in self.convex_hull:\n        minx, miny, maxx, maxy = hull.bounds\n\n        u_min = np.ceil(minx / resolution) * resolution\n        v_min = np.ceil(miny / resolution) * resolution\n        u_max = np.floor(maxx / resolution) * resolution\n        v_max = np.floor(maxy / resolution) * resolution\n\n        # Creating a prepared geometry improves performance for contains checks\n        hull_prep = shapely_prep(hull)\n\n        u_values = np.arange(u_min, u_max + resolution / 2, resolution)\n        v_values = np.arange(v_min, v_max + resolution / 2, resolution)\n\n        contained_points = []\n        for u in u_values:\n            for v in v_values:\n                point = Point(u, v)\n                if hull_prep.contains(point) or hull_prep.intersects(point):\n                    contained_points.append((u, v))\n\n        pixels.append(Pixels.from_iterable(contained_points))\n\n    return pixels\n</code></pre>"},{"location":"api/features/features/","title":"Features","text":""},{"location":"api/features/features/#siapy.features.features","title":"siapy.features.features","text":""},{"location":"api/features/features/#siapy.features.features.AutoFeatClassification","title":"AutoFeatClassification","text":"<pre><code>AutoFeatClassification(*, categorical_cols: list | None = None, feateng_cols: list | None = None, units: dict | None = None, feateng_steps: int = 2, featsel_runs: int = 5, max_gb: int | None = None, transformations: list[str] | tuple[str, ...] = ('1/', 'exp', 'log', 'abs', 'sqrt', '^2', '^3'), apply_pi_theorem: bool = True, always_return_numpy: bool = False, n_jobs: int = 1, verbose: int = 0, random_seed: int | None = None)\n</code></pre> <p>               Bases: <code>AutoFeatClassifier</code></p> Source code in <code>siapy/features/features.py</code> <pre><code>def __init__(\n    self,\n    *,\n    categorical_cols: list | None = None,\n    feateng_cols: list | None = None,\n    units: dict | None = None,\n    feateng_steps: int = 2,\n    featsel_runs: int = 5,\n    max_gb: int | None = None,\n    transformations: list[str] | tuple[str, ...] = (\n        \"1/\",\n        \"exp\",\n        \"log\",\n        \"abs\",\n        \"sqrt\",\n        \"^2\",\n        \"^3\",\n    ),\n    apply_pi_theorem: bool = True,\n    always_return_numpy: bool = False,\n    n_jobs: int = 1,\n    verbose: int = 0,\n    random_seed: int | None = None,\n):\n    self.random_seed = random_seed\n    set_random_seed(self.random_seed)\n    super().__init__(\n        categorical_cols=categorical_cols,\n        feateng_cols=feateng_cols,\n        units=units,\n        feateng_steps=feateng_steps,\n        featsel_runs=featsel_runs,\n        max_gb=max_gb,\n        transformations=transformations,\n        apply_pi_theorem=apply_pi_theorem,\n        always_return_numpy=always_return_numpy,\n        n_jobs=n_jobs,\n        verbose=verbose,\n    )\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoFeatClassification.random_seed","title":"random_seed  <code>instance-attribute</code>","text":"<pre><code>random_seed = random_seed\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoFeatClassification.fit","title":"fit","text":"<pre><code>fit(data: ndarray | DataFrame, target: ndarray | DataFrame)\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def fit(self, data: np.ndarray | pd.DataFrame, target: np.ndarray | pd.DataFrame):\n    set_random_seed(self.random_seed)\n    super().fit(data, target)\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoFeatClassification.transform","title":"transform","text":"<pre><code>transform(data: ndarray | DataFrame) -&gt; ndarray | DataFrame\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def transform(self, data: np.ndarray | pd.DataFrame) -&gt; np.ndarray | pd.DataFrame:\n    set_random_seed(self.random_seed)\n    data_transformed = super().transform(data)\n    return data_transformed\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoFeatClassification.fit_transform","title":"fit_transform","text":"<pre><code>fit_transform(data: ndarray | DataFrame, target: ndarray | DataFrame) -&gt; ndarray | DataFrame\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def fit_transform(\n    self, data: np.ndarray | pd.DataFrame, target: np.ndarray | pd.DataFrame\n) -&gt; np.ndarray | pd.DataFrame:\n    set_random_seed(self.random_seed)\n    data_transformed = super().fit_transform(data, target)\n    return data_transformed\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoFeatRegression","title":"AutoFeatRegression","text":"<pre><code>AutoFeatRegression(*, categorical_cols: list | None = None, feateng_cols: list | None = None, units: dict | None = None, feateng_steps: int = 2, featsel_runs: int = 5, max_gb: int | None = None, transformations: list[str] | tuple[str, ...] = ('1/', 'exp', 'log', 'abs', 'sqrt', '^2', '^3'), apply_pi_theorem: bool = True, always_return_numpy: bool = False, n_jobs: int = 1, verbose: int = 0, random_seed: int | None = None)\n</code></pre> <p>               Bases: <code>AutoFeatRegressor</code></p> Source code in <code>siapy/features/features.py</code> <pre><code>def __init__(\n    self,\n    *,\n    categorical_cols: list | None = None,\n    feateng_cols: list | None = None,\n    units: dict | None = None,\n    feateng_steps: int = 2,\n    featsel_runs: int = 5,\n    max_gb: int | None = None,\n    transformations: list[str] | tuple[str, ...] = (\n        \"1/\",\n        \"exp\",\n        \"log\",\n        \"abs\",\n        \"sqrt\",\n        \"^2\",\n        \"^3\",\n    ),\n    apply_pi_theorem: bool = True,\n    always_return_numpy: bool = False,\n    n_jobs: int = 1,\n    verbose: int = 0,\n    random_seed: int | None = None,\n):\n    self.random_seed = random_seed\n    set_random_seed(self.random_seed)\n    super().__init__(\n        categorical_cols=categorical_cols,\n        feateng_cols=feateng_cols,\n        units=units,\n        feateng_steps=feateng_steps,\n        featsel_runs=featsel_runs,\n        max_gb=max_gb,\n        transformations=transformations,\n        apply_pi_theorem=apply_pi_theorem,\n        always_return_numpy=always_return_numpy,\n        n_jobs=n_jobs,\n        verbose=verbose,\n    )\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoFeatRegression.random_seed","title":"random_seed  <code>instance-attribute</code>","text":"<pre><code>random_seed = random_seed\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoFeatRegression.fit","title":"fit","text":"<pre><code>fit(data: ndarray | DataFrame, target: ndarray | DataFrame)\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def fit(self, data: np.ndarray | pd.DataFrame, target: np.ndarray | pd.DataFrame):\n    set_random_seed(self.random_seed)\n    super().fit(data, target)\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoFeatRegression.transform","title":"transform","text":"<pre><code>transform(data: ndarray | DataFrame) -&gt; ndarray | DataFrame\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def transform(self, data: np.ndarray | pd.DataFrame) -&gt; np.ndarray | pd.DataFrame:\n    set_random_seed(self.random_seed)\n    data_transformed = super().transform(data)\n    return data_transformed\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoFeatRegression.fit_transform","title":"fit_transform","text":"<pre><code>fit_transform(data: ndarray | DataFrame, target: ndarray | DataFrame) -&gt; ndarray | DataFrame\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def fit_transform(\n    self, data: np.ndarray | pd.DataFrame, target: np.ndarray | pd.DataFrame\n) -&gt; np.ndarray | pd.DataFrame:\n    set_random_seed(self.random_seed)\n    data_transformed = super().fit_transform(data, target)\n    return data_transformed\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndices","title":"AutoSpectralIndices","text":"<pre><code>AutoSpectralIndices(problem_type: Literal['regression', 'classification'], spectral_indices: str | Iterable[str], *, selector_config: FeatureSelectorConfig = FeatureSelectorConfig(), bands_map: dict[str, str] | None = None, merge_with_original: bool = True)\n</code></pre> <p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> Source code in <code>siapy/features/features.py</code> <pre><code>def __init__(\n    self,\n    problem_type: Literal[\"regression\", \"classification\"],\n    spectral_indices: str | Iterable[str],\n    *,\n    selector_config: FeatureSelectorConfig = FeatureSelectorConfig(),\n    bands_map: dict[str, str] | None = None,\n    merge_with_original: bool = True,\n):\n    self.spectral_indices = spectral_indices\n    self.selector = feature_selector_factory(problem_type=problem_type, config=selector_config)\n    self.bands_map = bands_map\n    self.merge_with_original = merge_with_original\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndices.spectral_indices","title":"spectral_indices  <code>instance-attribute</code>","text":"<pre><code>spectral_indices = spectral_indices\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndices.selector","title":"selector  <code>instance-attribute</code>","text":"<pre><code>selector = feature_selector_factory(problem_type=problem_type, config=selector_config)\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndices.bands_map","title":"bands_map  <code>instance-attribute</code>","text":"<pre><code>bands_map = bands_map\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndices.merge_with_original","title":"merge_with_original  <code>instance-attribute</code>","text":"<pre><code>merge_with_original = merge_with_original\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndices.fit","title":"fit","text":"<pre><code>fit(data: DataFrame, target: Series) -&gt; BaseEstimator\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def fit(self, data: pd.DataFrame, target: pd.Series) -&gt; BaseEstimator:\n    df_indices = compute_spectral_indices(\n        data=data,\n        spectral_indices=self.spectral_indices,\n        bands_map=self.bands_map,\n    )\n    self.selector.fit(df_indices, target)\n    return self\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndices.transform","title":"transform","text":"<pre><code>transform(data: DataFrame) -&gt; DataFrame\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def transform(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n    df_indices = compute_spectral_indices(\n        data=data,\n        spectral_indices=self.spectral_indices,\n        bands_map=self.bands_map,\n    )\n    if hasattr(self.selector[1], \"k_feature_idx_\"):\n        columns_select_idx = list(self.selector[1].k_feature_idx_)\n        df_indices = df_indices.iloc[:, columns_select_idx]\n    else:\n        raise MethodNotImplementedError(self.selector[1].__class__.__name__, \"k_feature_idx_\")\n    if self.merge_with_original:\n        return pd.concat([data, df_indices], axis=1)\n    return df_indices\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndices.fit_transform","title":"fit_transform","text":"<pre><code>fit_transform(data: DataFrame, target: Series) -&gt; DataFrame\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def fit_transform(self, data: pd.DataFrame, target: pd.Series) -&gt; pd.DataFrame:\n    self.fit(data, target)\n    return self.transform(data)\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesClassification","title":"AutoSpectralIndicesClassification","text":"<pre><code>AutoSpectralIndicesClassification(spectral_indices: str | Iterable[str], *, selector_config: FeatureSelectorConfig = FeatureSelectorConfig(), bands_map: dict[str, str] | None = None, merge_with_original: bool = True)\n</code></pre> <p>               Bases: <code>AutoSpectralIndices</code></p> Source code in <code>siapy/features/features.py</code> <pre><code>def __init__(\n    self,\n    spectral_indices: str | Iterable[str],\n    *,\n    selector_config: FeatureSelectorConfig = FeatureSelectorConfig(),\n    bands_map: dict[str, str] | None = None,\n    merge_with_original: bool = True,\n):\n    super().__init__(\n        problem_type=\"classification\",\n        spectral_indices=spectral_indices,\n        selector_config=selector_config,\n        bands_map=bands_map,\n        merge_with_original=merge_with_original,\n    )\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesClassification.spectral_indices","title":"spectral_indices  <code>instance-attribute</code>","text":"<pre><code>spectral_indices = spectral_indices\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesClassification.selector","title":"selector  <code>instance-attribute</code>","text":"<pre><code>selector = feature_selector_factory(problem_type=problem_type, config=selector_config)\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesClassification.bands_map","title":"bands_map  <code>instance-attribute</code>","text":"<pre><code>bands_map = bands_map\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesClassification.merge_with_original","title":"merge_with_original  <code>instance-attribute</code>","text":"<pre><code>merge_with_original = merge_with_original\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesClassification.fit","title":"fit","text":"<pre><code>fit(data: DataFrame, target: Series) -&gt; BaseEstimator\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def fit(self, data: pd.DataFrame, target: pd.Series) -&gt; BaseEstimator:\n    df_indices = compute_spectral_indices(\n        data=data,\n        spectral_indices=self.spectral_indices,\n        bands_map=self.bands_map,\n    )\n    self.selector.fit(df_indices, target)\n    return self\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesClassification.transform","title":"transform","text":"<pre><code>transform(data: DataFrame) -&gt; DataFrame\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def transform(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n    df_indices = compute_spectral_indices(\n        data=data,\n        spectral_indices=self.spectral_indices,\n        bands_map=self.bands_map,\n    )\n    if hasattr(self.selector[1], \"k_feature_idx_\"):\n        columns_select_idx = list(self.selector[1].k_feature_idx_)\n        df_indices = df_indices.iloc[:, columns_select_idx]\n    else:\n        raise MethodNotImplementedError(self.selector[1].__class__.__name__, \"k_feature_idx_\")\n    if self.merge_with_original:\n        return pd.concat([data, df_indices], axis=1)\n    return df_indices\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesClassification.fit_transform","title":"fit_transform","text":"<pre><code>fit_transform(data: DataFrame, target: Series) -&gt; DataFrame\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def fit_transform(self, data: pd.DataFrame, target: pd.Series) -&gt; pd.DataFrame:\n    self.fit(data, target)\n    return self.transform(data)\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesRegression","title":"AutoSpectralIndicesRegression","text":"<pre><code>AutoSpectralIndicesRegression(spectral_indices: str | Iterable[str], *, selector_config: FeatureSelectorConfig = FeatureSelectorConfig(), bands_map: dict[str, str] | None = None, merge_with_original: bool = True)\n</code></pre> <p>               Bases: <code>AutoSpectralIndices</code></p> Source code in <code>siapy/features/features.py</code> <pre><code>def __init__(\n    self,\n    spectral_indices: str | Iterable[str],\n    *,\n    selector_config: FeatureSelectorConfig = FeatureSelectorConfig(),\n    bands_map: dict[str, str] | None = None,\n    merge_with_original: bool = True,\n):\n    super().__init__(\n        problem_type=\"regression\",\n        spectral_indices=spectral_indices,\n        selector_config=selector_config,\n        bands_map=bands_map,\n        merge_with_original=merge_with_original,\n    )\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesRegression.spectral_indices","title":"spectral_indices  <code>instance-attribute</code>","text":"<pre><code>spectral_indices = spectral_indices\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesRegression.selector","title":"selector  <code>instance-attribute</code>","text":"<pre><code>selector = feature_selector_factory(problem_type=problem_type, config=selector_config)\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesRegression.bands_map","title":"bands_map  <code>instance-attribute</code>","text":"<pre><code>bands_map = bands_map\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesRegression.merge_with_original","title":"merge_with_original  <code>instance-attribute</code>","text":"<pre><code>merge_with_original = merge_with_original\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesRegression.fit","title":"fit","text":"<pre><code>fit(data: DataFrame, target: Series) -&gt; BaseEstimator\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def fit(self, data: pd.DataFrame, target: pd.Series) -&gt; BaseEstimator:\n    df_indices = compute_spectral_indices(\n        data=data,\n        spectral_indices=self.spectral_indices,\n        bands_map=self.bands_map,\n    )\n    self.selector.fit(df_indices, target)\n    return self\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesRegression.transform","title":"transform","text":"<pre><code>transform(data: DataFrame) -&gt; DataFrame\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def transform(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n    df_indices = compute_spectral_indices(\n        data=data,\n        spectral_indices=self.spectral_indices,\n        bands_map=self.bands_map,\n    )\n    if hasattr(self.selector[1], \"k_feature_idx_\"):\n        columns_select_idx = list(self.selector[1].k_feature_idx_)\n        df_indices = df_indices.iloc[:, columns_select_idx]\n    else:\n        raise MethodNotImplementedError(self.selector[1].__class__.__name__, \"k_feature_idx_\")\n    if self.merge_with_original:\n        return pd.concat([data, df_indices], axis=1)\n    return df_indices\n</code></pre>"},{"location":"api/features/features/#siapy.features.features.AutoSpectralIndicesRegression.fit_transform","title":"fit_transform","text":"<pre><code>fit_transform(data: DataFrame, target: Series) -&gt; DataFrame\n</code></pre> Source code in <code>siapy/features/features.py</code> <pre><code>def fit_transform(self, data: pd.DataFrame, target: pd.Series) -&gt; pd.DataFrame:\n    self.fit(data, target)\n    return self.transform(data)\n</code></pre>"},{"location":"api/features/helpers/","title":"Helpers","text":""},{"location":"api/features/helpers/#siapy.features.helpers","title":"siapy.features.helpers","text":""},{"location":"api/features/helpers/#siapy.features.helpers.FeatureSelectorConfig","title":"FeatureSelectorConfig","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/features/helpers/#siapy.features.helpers.FeatureSelectorConfig.k_features","title":"k_features  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>k_features: int | str | tuple[int, ...] = (1, 20)\n</code></pre>"},{"location":"api/features/helpers/#siapy.features.helpers.FeatureSelectorConfig.cv","title":"cv  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cv: int = 3\n</code></pre>"},{"location":"api/features/helpers/#siapy.features.helpers.FeatureSelectorConfig.forward","title":"forward  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>forward: bool = True\n</code></pre>"},{"location":"api/features/helpers/#siapy.features.helpers.FeatureSelectorConfig.floating","title":"floating  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>floating: bool = True\n</code></pre>"},{"location":"api/features/helpers/#siapy.features.helpers.FeatureSelectorConfig.verbose","title":"verbose  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verbose: int = 2\n</code></pre>"},{"location":"api/features/helpers/#siapy.features.helpers.FeatureSelectorConfig.n_jobs","title":"n_jobs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_jobs: int = 1\n</code></pre>"},{"location":"api/features/helpers/#siapy.features.helpers.FeatureSelectorConfig.pre_dispatch","title":"pre_dispatch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pre_dispatch: int | str = '2*n_jobs'\n</code></pre>"},{"location":"api/features/helpers/#siapy.features.helpers.FeatureSelectorConfig.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True, validate_assignment=True)\n</code></pre>"},{"location":"api/features/helpers/#siapy.features.helpers.feature_selector_factory","title":"feature_selector_factory","text":"<pre><code>feature_selector_factory(problem_type: Literal['regression', 'classification'], *, k_features: int | str | tuple[int, ...] = (1, 20), cv: int = 3, forward: bool = True, floating: bool = True, verbose: int = 2, n_jobs: int = 1, pre_dispatch: int | str = '2*n_jobs', config: FeatureSelectorConfig | None = None) -&gt; Pipeline\n</code></pre> Source code in <code>siapy/features/helpers.py</code> <pre><code>def feature_selector_factory(\n    problem_type: Literal[\"regression\", \"classification\"],\n    *,\n    k_features: Annotated[\n        int | str | tuple[int, ...],\n        \"can be: 'best' - most extensive, (1, n) - check range of features, n - exact number of features\",\n    ] = (1, 20),\n    cv: int = 3,\n    forward: Annotated[bool, \"selection in forward direction\"] = True,\n    floating: Annotated[bool, \"floating algorithm - can go back and remove features once added\"] = True,\n    verbose: int = 2,\n    n_jobs: int = 1,\n    pre_dispatch: int | str = \"2*n_jobs\",\n    config: Annotated[\n        FeatureSelectorConfig | None,\n        \"If provided, other arguments are overwritten by config values\",\n    ] = None,\n) -&gt; Pipeline:\n    if config:\n        k_features = config.k_features\n        cv = config.cv\n        forward = config.forward\n        floating = config.floating\n        verbose = config.verbose\n        n_jobs = config.n_jobs\n        pre_dispatch = config.pre_dispatch\n\n    if problem_type == \"regression\":\n        algo = Ridge()\n        scoring = \"neg_mean_squared_error\"\n    elif problem_type == \"classification\":\n        algo = RidgeClassifier()\n        scoring = \"f1_weighted\"\n    else:\n        raise InvalidInputError(\n            problem_type,\n            \"Invalid problem type, possible values are: 'regression' or 'classification'\",\n        )\n    sfs = SequentialFeatureSelector(\n        estimator=algo,\n        k_features=k_features,  # type: ignore # noqa\n        forward=forward,\n        floating=floating,\n        verbose=verbose,\n        scoring=scoring,\n        cv=cv,\n        n_jobs=n_jobs,\n        pre_dispatch=pre_dispatch,  # type: ignore\n    )\n    return make_pipeline(RobustScaler(), sfs, memory=None)\n</code></pre>"},{"location":"api/features/spectral_indices/","title":"Spectral Indices","text":""},{"location":"api/features/spectral_indices/#siapy.features.spectral_indices","title":"siapy.features.spectral_indices","text":""},{"location":"api/features/spectral_indices/#siapy.features.spectral_indices.get_spectral_indices","title":"get_spectral_indices","text":"<pre><code>get_spectral_indices(bands_acronym: str | Iterable[str]) -&gt; dict[str, SpectralIndex]\n</code></pre> Source code in <code>siapy/features/spectral_indices.py</code> <pre><code>def get_spectral_indices(\n    bands_acronym: str | Iterable[str],\n) -&gt; dict[str, spyndex.axioms.SpectralIndex]:\n    bands_acronym = _convert_str_to_list(bands_acronym)\n    bands_acronym_set = set(bands_acronym)\n\n    if not bands_acronym_set.issubset(list(spyndex.bands)):\n        raise InvalidInputError(\n            {\n                \"received_bands_acronym\": bands_acronym_set,\n                \"valid_bands_acronym\": list(spyndex.bands),\n            },\n            \"Invalid input argument for 'bands_acronym'. Please ensure that all elements in 'bands_acronym' are valid band acronyms.\",\n        )\n\n    spectral_indexes = {}\n    for name in spyndex.indices.to_dict():\n        index = spyndex.indices[name]\n        if set(index.bands).issubset(bands_acronym_set):\n            spectral_indexes[name] = index\n\n    return spectral_indexes\n</code></pre>"},{"location":"api/features/spectral_indices/#siapy.features.spectral_indices.compute_spectral_indices","title":"compute_spectral_indices","text":"<pre><code>compute_spectral_indices(data: DataFrame, spectral_indices: str | Iterable[str], bands_map: dict[str, str] | None = None, remove_nan_and_constants: bool = True) -&gt; DataFrame\n</code></pre> Source code in <code>siapy/features/spectral_indices.py</code> <pre><code>def compute_spectral_indices(\n    data: pd.DataFrame,\n    spectral_indices: str | Iterable[str],\n    bands_map: dict[str, str] | None = None,\n    remove_nan_and_constants: bool = True,\n) -&gt; pd.DataFrame:\n    spectral_indices = _convert_str_to_list(spectral_indices)\n\n    params = {}\n    for band in data.columns:\n        if bands_map is not None and band in bands_map.keys():\n            if bands_map[band] not in list(spyndex.bands):\n                raise InvalidInputError(\n                    {\n                        \"received_band_mapping\": bands_map[band],\n                        \"valid_bands_acronym\": list(spyndex.bands),\n                    },\n                    f\"Invalid band mapping is not a recognized band acronym. \\n\"\n                    f\"Received mapping: {band} -&gt; {bands_map[band]}. \\n\"\n                    \"Please ensure that all values in 'bands_map' are valid band acronyms.\",\n                )\n            params[bands_map[band]] = data[band]\n        else:\n            if band not in list(spyndex.bands):\n                raise InvalidInputError(\n                    {\n                        \"received_band\": band,\n                        \"valid_bands_acronym\": list(spyndex.bands),\n                    },\n                    f\"Invalid band: '{band}' is not a recognized band acronym. \\n\"\n                    \"Please ensure that all columns in 'data' are valid band acronyms.\",\n                )\n            params[band] = data[band]\n\n    df = spyndex.computeIndex(index=list(spectral_indices), params=params)\n    if remove_nan_and_constants:\n        # Drop columns with inf or NaN values\n        df = df.drop(df.columns[df.isin([np.inf, -np.inf, np.nan]).any()], axis=1)\n        # Drop columns with constant values\n        df = df.drop(df.columns[df.nunique() == 1], axis=1)\n    return df\n</code></pre>"},{"location":"api/models/metrics/","title":"Metrics","text":""},{"location":"api/models/metrics/#siapy.models.metrics","title":"siapy.models.metrics","text":""},{"location":"api/models/metrics/#siapy.models.metrics.ClassificationMetrics","title":"ClassificationMetrics","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"api/models/metrics/#siapy.models.metrics.ClassificationMetrics.accuracy","title":"accuracy  <code>instance-attribute</code>","text":"<pre><code>accuracy: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.ClassificationMetrics.precision","title":"precision  <code>instance-attribute</code>","text":"<pre><code>precision: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.ClassificationMetrics.recall","title":"recall  <code>instance-attribute</code>","text":"<pre><code>recall: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.ClassificationMetrics.f1","title":"f1  <code>instance-attribute</code>","text":"<pre><code>f1: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.ClassificationMetrics.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> Source code in <code>siapy/models/metrics.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    return self._asdict()\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.RegressionMetrics","title":"RegressionMetrics","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"api/models/metrics/#siapy.models.metrics.RegressionMetrics.mae","title":"mae  <code>instance-attribute</code>","text":"<pre><code>mae: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.RegressionMetrics.mse","title":"mse  <code>instance-attribute</code>","text":"<pre><code>mse: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.RegressionMetrics.rmse","title":"rmse  <code>instance-attribute</code>","text":"<pre><code>rmse: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.RegressionMetrics.r2","title":"r2  <code>instance-attribute</code>","text":"<pre><code>r2: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.RegressionMetrics.pe","title":"pe  <code>instance-attribute</code>","text":"<pre><code>pe: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.RegressionMetrics.maxe","title":"maxe  <code>instance-attribute</code>","text":"<pre><code>maxe: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.RegressionMetrics.nrmse_mean","title":"nrmse_mean  <code>instance-attribute</code>","text":"<pre><code>nrmse_mean: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.RegressionMetrics.nrmse_range","title":"nrmse_range  <code>instance-attribute</code>","text":"<pre><code>nrmse_range: float\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.RegressionMetrics.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> Source code in <code>siapy/models/metrics.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    return self._asdict()\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.normalized_RMSE","title":"normalized_RMSE","text":"<pre><code>normalized_RMSE(y_true: ndarray, y_pred: ndarray, normalize_by: Literal['range', 'mean'] = 'range')\n</code></pre> Source code in <code>siapy/models/metrics.py</code> <pre><code>def normalized_RMSE(\n    y_true: np.ndarray,\n    y_pred: np.ndarray,\n    normalize_by: Literal[\"range\", \"mean\"] = \"range\",\n):\n    rmse = mean_squared_error(y_true, y_pred, squared=False)\n    if normalize_by == \"range\":\n        normalizer = np.max(y_true) - np.min(y_true)\n    elif normalize_by == \"mean\":\n        normalizer = np.mean(y_true)\n    else:\n        raise InvalidInputError(\n            input_value=normalize_by,\n            message=\"Unknown normalizer. Possible values are: 'range' or 'mean'.\",\n        )\n    return rmse / normalizer\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.calculate_classification_metrics","title":"calculate_classification_metrics","text":"<pre><code>calculate_classification_metrics(y_true, y_pred, average: Literal['micro', 'macro', 'samples', 'weighted', 'binary'] | None = 'weighted')\n</code></pre> Source code in <code>siapy/models/metrics.py</code> <pre><code>def calculate_classification_metrics(\n    y_true,\n    y_pred,\n    average: Literal[\"micro\", \"macro\", \"samples\", \"weighted\", \"binary\"] | None = \"weighted\",\n):\n    accuracy = accuracy_score(y_true, y_pred)\n    precision = precision_score(y_true, y_pred, average=average)\n    recall = recall_score(y_true, y_pred, average=average)\n    f1 = f1_score(y_true, y_pred, average=average)\n    return ClassificationMetrics(\n        accuracy=accuracy,\n        precision=precision,\n        recall=recall,\n        f1=f1,\n    )\n</code></pre>"},{"location":"api/models/metrics/#siapy.models.metrics.calculate_regression_metrics","title":"calculate_regression_metrics","text":"<pre><code>calculate_regression_metrics(y_true, y_pred)\n</code></pre> Source code in <code>siapy/models/metrics.py</code> <pre><code>def calculate_regression_metrics(y_true, y_pred):\n    mae = mean_absolute_error(y_true, y_pred)\n    mse = mean_squared_error(y_true, y_pred, squared=True)\n    rmse = mean_squared_error(y_true, y_pred, squared=False)\n    r2 = r2_score(y_true, y_pred)\n    pe = mean_absolute_percentage_error(y_true, y_pred)\n    maxe = max_error(y_true, y_pred)\n    nrmse_mean = normalized_RMSE(y_true, y_pred, normalize_by=\"mean\")\n    nrmse_range = normalized_RMSE(y_true, y_pred, normalize_by=\"range\")\n    return RegressionMetrics(\n        mae=mae,\n        mse=mse,\n        rmse=rmse,\n        r2=r2,\n        pe=pe,\n        maxe=maxe,\n        nrmse_mean=nrmse_mean,\n        nrmse_range=nrmse_range,\n    )\n</code></pre>"},{"location":"api/optimizers/configs/","title":"Configs","text":""},{"location":"api/optimizers/configs/#siapy.optimizers.configs","title":"siapy.optimizers.configs","text":""},{"location":"api/optimizers/configs/#siapy.optimizers.configs.CreateStudyConfig","title":"CreateStudyConfig","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.CreateStudyConfig.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.CreateStudyConfig.storage","title":"storage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>storage: str | BaseStorage | None = None\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.CreateStudyConfig.sampler","title":"sampler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sampler: BaseSampler | None = None\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.CreateStudyConfig.pruner","title":"pruner  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pruner: BasePruner | None = None\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.CreateStudyConfig.study_name","title":"study_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>study_name: str | None = None\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.CreateStudyConfig.direction","title":"direction  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>direction: Literal['maximize', 'minimize'] | StudyDirection | None = 'minimize'\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.CreateStudyConfig.load_if_exists","title":"load_if_exists  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>load_if_exists: bool = False\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.OptimizeStudyConfig","title":"OptimizeStudyConfig","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.OptimizeStudyConfig.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.OptimizeStudyConfig.n_trials","title":"n_trials  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_trials: int | None = None\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.OptimizeStudyConfig.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: float | None = None\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.OptimizeStudyConfig.n_jobs","title":"n_jobs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_jobs: int = -1\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.OptimizeStudyConfig.catch","title":"catch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>catch: Iterable[type[Exception]] | type[Exception] = ()\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.OptimizeStudyConfig.callbacks","title":"callbacks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>callbacks: list[Callable[[Study, FrozenTrial], None]] | None = None\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.OptimizeStudyConfig.gc_after_trial","title":"gc_after_trial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gc_after_trial: bool = False\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.OptimizeStudyConfig.show_progress_bar","title":"show_progress_bar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_progress_bar: bool = True\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.TabularOptimizerConfig","title":"TabularOptimizerConfig","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.TabularOptimizerConfig.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.TabularOptimizerConfig.create_study","title":"create_study  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>create_study: CreateStudyConfig = CreateStudyConfig()\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.TabularOptimizerConfig.optimize_study","title":"optimize_study  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>optimize_study: OptimizeStudyConfig = OptimizeStudyConfig()\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.TabularOptimizerConfig.scorer","title":"scorer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scorer: Scorer | None = None\n</code></pre>"},{"location":"api/optimizers/configs/#siapy.optimizers.configs.TabularOptimizerConfig.trial_parameters","title":"trial_parameters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trial_parameters: TrialParameters | None = None\n</code></pre>"},{"location":"api/optimizers/evaluators/","title":"Evaluators","text":""},{"location":"api/optimizers/evaluators/#siapy.optimizers.evaluators","title":"siapy.optimizers.evaluators","text":""},{"location":"api/optimizers/evaluators/#siapy.optimizers.evaluators.ScorerFuncType","title":"ScorerFuncType  <code>module-attribute</code>","text":"<pre><code>ScorerFuncType = Callable[[BaseEstimator, ArrayLike2dType, ArrayLike1dType], float]\n</code></pre>"},{"location":"api/optimizers/evaluators/#siapy.optimizers.evaluators.cross_validation","title":"cross_validation","text":"<pre><code>cross_validation(model: BaseEstimator, X: ArrayLike2dType, y: ArrayLike1dType, X_val: ArrayLike2dType | None = None, y_val: ArrayLike1dType | None = None, *, groups: ArrayLike1dType | None = None, scoring: str | ScorerFuncType | None = None, cv: int | BaseCrossValidator | Iterable | None = None, n_jobs: int | None = 1, verbose: int = 0, params: dict[str, Any] | None = None, pre_dispatch: int | str = 1, error_score: Literal['raise'] | int = 0) -&gt; float\n</code></pre> Source code in <code>siapy/optimizers/evaluators.py</code> <pre><code>def cross_validation(\n    model: BaseEstimator,\n    X: ArrayLike2dType,\n    y: ArrayLike1dType,\n    X_val: Annotated[ArrayLike2dType | None, \"Not used, only for compatibility\"] = None,\n    y_val: Annotated[ArrayLike1dType | None, \"Not used, only for compatibility\"] = None,\n    *,\n    groups: ArrayLike1dType | None = None,\n    scoring: str | ScorerFuncType | None = None,\n    cv: int | BaseCrossValidator | Iterable | None = None,\n    n_jobs: int | None = 1,\n    verbose: int = 0,\n    params: dict[str, Any] | None = None,\n    pre_dispatch: int | str = 1,\n    error_score: Literal[\"raise\"] | int = 0,\n) -&gt; float:\n    if X_val is not None or y_val is not None:\n        logger.info(\"Specification of X_val and y_val is redundant for cross_validation.These parameters are ignored.\")\n    check_model_prediction_methods(model)\n    score = cross_val_score(\n        estimator=model,\n        X=X,  # type: ignore\n        y=y,\n        groups=groups,\n        scoring=scoring,\n        cv=cv,\n        n_jobs=n_jobs,\n        verbose=verbose,\n        params=params,\n        pre_dispatch=pre_dispatch,\n        error_score=error_score,\n    )\n    return score.mean()\n</code></pre>"},{"location":"api/optimizers/evaluators/#siapy.optimizers.evaluators.hold_out_validation","title":"hold_out_validation","text":"<pre><code>hold_out_validation(model: BaseEstimator, X: ArrayLike2dType, y: ArrayLike1dType, X_val: ArrayLike2dType | None = None, y_val: ArrayLike1dType | None = None, *, scoring: str | ScorerFuncType | None = None, test_size: float | None = 0.2, random_state: int | None = None, shuffle: bool = True, stratify: ndarray | None = None) -&gt; float\n</code></pre> Source code in <code>siapy/optimizers/evaluators.py</code> <pre><code>def hold_out_validation(\n    model: BaseEstimator,\n    X: ArrayLike2dType,\n    y: ArrayLike1dType,\n    X_val: ArrayLike2dType | None = None,\n    y_val: ArrayLike1dType | None = None,\n    *,\n    scoring: str | ScorerFuncType | None = None,\n    test_size: float | None = 0.2,\n    random_state: int | None = None,\n    shuffle: bool = True,\n    stratify: np.ndarray | None = None,\n) -&gt; float:\n    if X_val is not None and y_val is not None:\n        x_train, x_test, y_train, y_test = X, X_val, y, y_val\n    elif X_val is not None or y_val is not None:\n        raise InvalidInputError(\n            input_value={\"X_val\": X_val, \"y_val\": y_val},\n            message=\"To manually define validation set, both X_val and y_val must be specified.\",\n        )\n    else:\n        x_train, x_test, y_train, y_test = train_test_split(\n            X,\n            y,\n            test_size=test_size,\n            random_state=random_state,\n            shuffle=shuffle,\n            stratify=stratify,\n        )\n    check_model_prediction_methods(model)\n    model.fit(x_train, y_train)  # type: ignore\n\n    if scoring:\n        if isinstance(scoring, str):\n            scoring_func = get_scorer(scoring)\n        else:\n            scoring_func = scoring\n        score = scoring_func(model, x_test, y_test)\n    else:\n        score = model.score(x_test, y_test)  # type: ignore\n    return score\n</code></pre>"},{"location":"api/optimizers/optimizers/","title":"Optimizers","text":""},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers","title":"siapy.optimizers.optimizers","text":""},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer","title":"TabularOptimizer","text":"<pre><code>TabularOptimizer(model: BaseEstimator, configs: TabularOptimizerConfig, X: ArrayLike2dType, y: ArrayLike1dType, X_val: ArrayLike2dType | None = None, y_val: ArrayLike1dType | None = None)\n</code></pre> Source code in <code>siapy/optimizers/optimizers.py</code> <pre><code>def __init__(\n    self,\n    model: BaseEstimator,\n    configs: TabularOptimizerConfig,\n    X: ArrayLike2dType,\n    y: ArrayLike1dType,\n    X_val: ArrayLike2dType | None = None,\n    y_val: ArrayLike1dType | None = None,\n):\n    self.model = model\n    self.configs = configs\n    self.X = X\n    self.y = y\n    self.X_val = X_val\n    self.y_val = y_val\n\n    self._study: optuna.study.Study | None = None\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = model\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.configs","title":"configs  <code>instance-attribute</code>","text":"<pre><code>configs = configs\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.X","title":"X  <code>instance-attribute</code>","text":"<pre><code>X = X\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y = y\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.X_val","title":"X_val  <code>instance-attribute</code>","text":"<pre><code>X_val = X_val\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.y_val","title":"y_val  <code>instance-attribute</code>","text":"<pre><code>y_val = y_val\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.study","title":"study  <code>property</code>","text":"<pre><code>study: Study | None\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.best_trial","title":"best_trial  <code>property</code>","text":"<pre><code>best_trial: FrozenTrial | None\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.from_tabular_dataset_data","title":"from_tabular_dataset_data  <code>classmethod</code>","text":"<pre><code>from_tabular_dataset_data(model: BaseEstimator, configs: TabularOptimizerConfig, data: TabularDatasetData, data_val: TabularDatasetData | None = None) -&gt; TabularOptimizer\n</code></pre> Source code in <code>siapy/optimizers/optimizers.py</code> <pre><code>@classmethod\ndef from_tabular_dataset_data(\n    cls,\n    model: BaseEstimator,\n    configs: TabularOptimizerConfig,\n    data: TabularDatasetData,\n    data_val: TabularDatasetData | None = None,\n) -&gt; \"TabularOptimizer\":\n    signals = data.signals\n    target = data.target\n    signals_val = data_val.signals if data_val else None\n    target_val = data_val.target if data_val else None\n\n    if target is None:\n        raise InvalidInputError(\n            input_value=target,\n            message=\"Target data is required for optimization.\",\n        )\n    if signals_val is not None and target_val is None:\n        raise InvalidInputError(\n            input_value={\n                \"signals_val\": signals_val,\n                \"target_val\": target_val,\n            },\n            message=(\n                \"If validation data (data_val) is provided, \"\n                \"validation targets (data_val.target) must also be provided.\"\n            ),\n        )\n    return cls(\n        model=model,\n        configs=configs,\n        X=signals,\n        y=target.value,\n        X_val=signals_val,\n        y_val=target_val.value if target_val else None,\n    )\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.run","title":"run","text":"<pre><code>run() -&gt; Study\n</code></pre> Source code in <code>siapy/optimizers/optimizers.py</code> <pre><code>def run(self) -&gt; optuna.study.Study:\n    study = optuna.create_study(**self.configs.create_study.model_dump())\n    study.optimize(\n        self.objective,\n        **self.configs.optimize_study.model_dump(),\n    )\n    if self.best_trial:\n        logger.info(\"Best scoring metric: %s\", self.best_trial.value)\n        logger.info(\"Best hyperparameters found were: %s\", self.best_trial.params)\n    self._study = study\n    return study\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.get_best_model","title":"get_best_model","text":"<pre><code>get_best_model() -&gt; BaseEstimator\n</code></pre> Source code in <code>siapy/optimizers/optimizers.py</code> <pre><code>def get_best_model(self) -&gt; BaseEstimator:\n    if self.best_trial is None:\n        raise InvalidInputError(\n            input_value=\"None\",\n            message=\"Study is not available for model refitting.\",\n        )\n\n    best_model = clone(self.model)\n    best_model.set_params(**self.best_trial.params)\n    best_model.fit(self.X, self.y)\n    return best_model\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.objective","title":"objective","text":"<pre><code>objective(trial: Trial) -&gt; float\n</code></pre> Source code in <code>siapy/optimizers/optimizers.py</code> <pre><code>def objective(self, trial: optuna.trial.Trial) -&gt; float:\n    params = self._trial_params(trial)\n    self.model = clone(self.model)\n    self.model.set_params(**params)\n    score = self.scorer()\n    return score\n</code></pre>"},{"location":"api/optimizers/optimizers/#siapy.optimizers.optimizers.TabularOptimizer.scorer","title":"scorer","text":"<pre><code>scorer() -&gt; float\n</code></pre> Source code in <code>siapy/optimizers/optimizers.py</code> <pre><code>def scorer(self) -&gt; float:\n    if self.configs.scorer is None:\n        raise InvalidInputError(\n            input_value=self.configs.scorer,\n            message=\"Scorer is not defined. Add scorer to configs or implement your custom scorer.\",\n        )\n    return self.configs.scorer(\n        model=self.model,\n        X=self.X,\n        y=self.y,\n        X_val=self.X_val,\n        y_val=self.y_val,\n    )\n</code></pre>"},{"location":"api/optimizers/parameters/","title":"Parameters","text":""},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters","title":"siapy.optimizers.parameters","text":""},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.ParametersDictType","title":"ParametersDictType  <code>module-attribute</code>","text":"<pre><code>ParametersDictType = dict[str, list[dict[str, Any]]]\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.FloatParameter","title":"FloatParameter","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.FloatParameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.FloatParameter.low","title":"low  <code>instance-attribute</code>","text":"<pre><code>low: float\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.FloatParameter.high","title":"high  <code>instance-attribute</code>","text":"<pre><code>high: float\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.FloatParameter.step","title":"step  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>step: float | None = None\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.FloatParameter.log","title":"log  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log: bool = False\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.IntParameter","title":"IntParameter","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.IntParameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.IntParameter.low","title":"low  <code>instance-attribute</code>","text":"<pre><code>low: int\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.IntParameter.high","title":"high  <code>instance-attribute</code>","text":"<pre><code>high: int\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.IntParameter.step","title":"step  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>step: int = 1\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.IntParameter.log","title":"log  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log: bool = False\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.CategoricalParameter","title":"CategoricalParameter","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.CategoricalParameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.CategoricalParameter.choices","title":"choices  <code>instance-attribute</code>","text":"<pre><code>choices: Sequence[None | bool | int | float | str]\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.TrialParameters","title":"TrialParameters  <code>dataclass</code>","text":"<pre><code>TrialParameters(float_parameters: list[FloatParameter] | None = None, int_parameters: list[IntParameter] | None = None, categorical_parameters: list[CategoricalParameter] | None = None)\n</code></pre> Source code in <code>siapy/optimizers/parameters.py</code> <pre><code>def __init__(\n    self,\n    float_parameters: list[FloatParameter] | None = None,\n    int_parameters: list[IntParameter] | None = None,\n    categorical_parameters: list[CategoricalParameter] | None = None,\n):\n    self._float_parameters = float_parameters or []\n    self._int_parameters = int_parameters or []\n    self._categorical_parameters = categorical_parameters or []\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.TrialParameters.float_parameters","title":"float_parameters  <code>property</code>","text":"<pre><code>float_parameters: list[FloatParameter]\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.TrialParameters.int_parameters","title":"int_parameters  <code>property</code>","text":"<pre><code>int_parameters: list[IntParameter]\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.TrialParameters.categorical_parameters","title":"categorical_parameters  <code>property</code>","text":"<pre><code>categorical_parameters: list[CategoricalParameter]\n</code></pre>"},{"location":"api/optimizers/parameters/#siapy.optimizers.parameters.TrialParameters.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(parameters: ParametersDictType) -&gt; TrialParameters\n</code></pre> Source code in <code>siapy/optimizers/parameters.py</code> <pre><code>@classmethod\ndef from_dict(cls, parameters: ParametersDictType) -&gt; \"TrialParameters\":\n    float_params = [FloatParameter(**fp) for fp in parameters.get(\"float_parameters\", [])]\n    int_params = [IntParameter(**ip) for ip in parameters.get(\"int_parameters\", [])]\n    cat_params = [CategoricalParameter(**cp) for cp in parameters.get(\"categorical_parameters\", [])]\n    return cls(\n        float_parameters=float_params,\n        int_parameters=int_params,\n        categorical_parameters=cat_params,\n    )\n</code></pre>"},{"location":"api/optimizers/scorers/","title":"Scorers","text":""},{"location":"api/optimizers/scorers/#siapy.optimizers.scorers","title":"siapy.optimizers.scorers","text":""},{"location":"api/optimizers/scorers/#siapy.optimizers.scorers.Scorer","title":"Scorer","text":"<pre><code>Scorer(scorer)\n</code></pre> Source code in <code>siapy/optimizers/scorers.py</code> <pre><code>def __init__(self, scorer):\n    self._scorer = scorer\n</code></pre>"},{"location":"api/optimizers/scorers/#siapy.optimizers.scorers.Scorer.init_cross_validator_scorer","title":"init_cross_validator_scorer  <code>classmethod</code>","text":"<pre><code>init_cross_validator_scorer(scoring: str | ScorerFuncType | None = None, cv: int | BaseCrossValidator | _RepeatedSplits | Iterable | Literal['RepeatedKFold', 'RepeatedStratifiedKFold'] | None = None, n_jobs: int | None = None) -&gt; Scorer\n</code></pre> Source code in <code>siapy/optimizers/scorers.py</code> <pre><code>@classmethod\ndef init_cross_validator_scorer(\n    cls,\n    scoring: str | ScorerFuncType | None = None,\n    cv: int\n    | model_selection.BaseCrossValidator\n    | model_selection._split._RepeatedSplits\n    | Iterable\n    | Literal[\"RepeatedKFold\", \"RepeatedStratifiedKFold\"]\n    | None = None,\n    n_jobs: Annotated[\n        int | None,\n        \"Number of jobs to run in parallel. `-1` means using all processors.\",\n    ] = None,\n) -&gt; \"Scorer\":\n    if isinstance(cv, str) and cv in [\n        \"RepeatedKFold\",\n        \"RepeatedStratifiedKFold\",\n    ]:\n        cv = initialize_object(\n            module=model_selection,\n            module_name=cv,\n            n_splits=3,\n            n_repeats=5,\n            random_state=0,\n        )\n    scorer = partial(\n        cross_validation,\n        scoring=scoring,\n        cv=cv,  # type: ignore\n        groups=None,\n        n_jobs=n_jobs,\n        verbose=0,\n        params=None,\n        pre_dispatch=1,\n        error_score=0,\n    )\n    return cls(scorer)\n</code></pre>"},{"location":"api/optimizers/scorers/#siapy.optimizers.scorers.Scorer.init_hold_out_scorer","title":"init_hold_out_scorer  <code>classmethod</code>","text":"<pre><code>init_hold_out_scorer(scoring: str | ScorerFuncType | None = None, test_size: float | None = 0.2, stratify: ndarray | None = None) -&gt; Scorer\n</code></pre> Source code in <code>siapy/optimizers/scorers.py</code> <pre><code>@classmethod\ndef init_hold_out_scorer(\n    cls,\n    scoring: str | ScorerFuncType | None = None,\n    test_size: float | None = 0.2,\n    stratify: np.ndarray | None = None,\n) -&gt; \"Scorer\":\n    scorer = partial(\n        hold_out_validation,\n        scoring=scoring,\n        test_size=test_size,\n        random_state=0,\n        shuffle=True,\n        stratify=stratify,\n    )\n    return cls(scorer)\n</code></pre>"},{"location":"api/transformations/corregistrator/","title":"Corregistrator","text":""},{"location":"api/transformations/corregistrator/#siapy.transformations.corregistrator","title":"siapy.transformations.corregistrator","text":""},{"location":"api/transformations/corregistrator/#siapy.transformations.corregistrator.map_affine_approx_2d","title":"map_affine_approx_2d","text":"<pre><code>map_affine_approx_2d(points_ref: ndarray, points_mov: ndarray) -&gt; ndarray\n</code></pre> <p>Affine transformation</p> Source code in <code>siapy/transformations/corregistrator.py</code> <pre><code>def map_affine_approx_2d(points_ref: np.ndarray, points_mov: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Affine transformation\"\"\"\n    # U = T*X -&gt; T = U*X'(X*X')^-1\n    matx_2d = points_ref.transpose() @ points_mov @ np.linalg.inv(points_mov.transpose() @ points_mov)\n    return matx_2d\n</code></pre>"},{"location":"api/transformations/corregistrator/#siapy.transformations.corregistrator.affine_matx_2d","title":"affine_matx_2d","text":"<pre><code>affine_matx_2d(scale: tuple[float, float] | Sequence[float] = (1, 1), trans: tuple[float, float] | Sequence[float] = (0, 0), rot: float = 0, shear: tuple[float, float] | Sequence[float] = (0, 0)) -&gt; ndarray\n</code></pre> <p>Create arbitrary affine transformation matrix</p> Source code in <code>siapy/transformations/corregistrator.py</code> <pre><code>def affine_matx_2d(\n    scale: tuple[float, float] | Sequence[float] = (1, 1),\n    trans: tuple[float, float] | Sequence[float] = (0, 0),\n    rot: float = 0,\n    shear: tuple[float, float] | Sequence[float] = (0, 0),\n) -&gt; np.ndarray:\n    \"\"\"Create arbitrary affine transformation matrix\"\"\"\n    rot = rot * np.pi / 180\n    matx_scale = np.array(((scale[0], 0, 0), (0, scale[1], 0), (0, 0, 1)))\n    matx_trans = np.array(((1, 0, trans[0]), (0, 1, trans[1]), (0, 0, 1)))\n    matx_rot = np.array(\n        (\n            (np.cos(rot), -np.sin(rot), 0),\n            (np.sin(rot), np.cos(rot), 0),\n            (0, 0, 1),\n        )\n    )\n    matx_shear = np.array(((1, shear[0], 0), (shear[1], 1, 0), (0, 0, 1)))\n    matx_2d = np.dot(matx_trans, np.dot(matx_shear, np.dot(matx_rot, matx_scale)))\n    return matx_2d\n</code></pre>"},{"location":"api/transformations/corregistrator/#siapy.transformations.corregistrator.align","title":"align","text":"<pre><code>align(pixels_ref: Pixels, pixels_mov: Pixels, *, eps: float = 1e-06, max_iter: int = 50, plot_progress: bool = False) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Align interactive corresponding points</p> Source code in <code>siapy/transformations/corregistrator.py</code> <pre><code>def align(\n    pixels_ref: Pixels,\n    pixels_mov: Pixels,\n    *,\n    eps: float = 1e-6,\n    max_iter: int = 50,\n    plot_progress: bool = False,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Align interactive corresponding points\"\"\"\n\n    points_ref = pixels_ref.df_homogenious().to_numpy()\n    points_mov = pixels_mov.df_homogenious().to_numpy()\n\n    matrices = []\n    errors = []\n    idx = 0\n    if plot_progress:\n        points_mov_orig = points_mov\n        fig = plt.figure()\n        ax = fig.add_subplot(111)\n\n    while True:\n        points_ref_corr = np.array(points_ref)\n        points_mov_corr = np.array(points_mov)\n\n        matx_2d_combined = map_affine_approx_2d(points_ref_corr, points_mov_corr)\n        points_mov = np.dot(points_mov, matx_2d_combined.transpose())\n\n        matrices.append(matx_2d_combined)\n        errors.append(np.sqrt(np.sum((points_ref_corr[:, :2] - points_mov_corr[:, :2]) ** 2)))\n        idx = idx + 1\n\n        # check for convergence\n        matx_diff = np.abs(matx_2d_combined - affine_matx_2d())\n        if idx &gt; max_iter or np.all(matx_diff &lt; eps):\n            break\n\n    matx_2d_combined = affine_matx_2d()  # initialize with identity matrix\n    for matx_2d in matrices:\n        if plot_progress:\n            points_mov_corr = np.dot(points_mov_orig, matx_2d_combined.transpose())\n            ax.clear()\n            ax.plot(points_ref[:, 0], points_ref[:, 1], \"ob\")\n            ax.plot(points_mov_corr[:, 0], points_mov_corr[:, 1], \"om\")\n            fig.canvas.draw()\n            plt.pause(1)\n\n        # multiply all matrices to get the final transformation\n        matx_2d_combined = np.dot(matx_2d, matx_2d_combined)\n\n    errors_np = np.array(errors)\n\n    return matx_2d_combined, errors_np\n</code></pre>"},{"location":"api/transformations/corregistrator/#siapy.transformations.corregistrator.transform","title":"transform","text":"<pre><code>transform(pixels: Pixels, transformation_matx: ndarray)\n</code></pre> <p>Transform pixels</p> Source code in <code>siapy/transformations/corregistrator.py</code> <pre><code>def transform(pixels: Pixels, transformation_matx: np.ndarray):\n    \"\"\"Transform pixels\"\"\"\n    points_transformed = np.dot(pixels.df_homogenious().to_numpy(), transformation_matx.transpose())\n    points_transformed = np.round(points_transformed[:, :2]).astype(\"int\")\n    return Pixels.from_iterable(points_transformed)\n</code></pre>"},{"location":"api/transformations/image/","title":"Image","text":""},{"location":"api/transformations/image/#siapy.transformations.image","title":"siapy.transformations.image","text":""},{"location":"api/transformations/image/#siapy.transformations.image.add_gaussian_noise","title":"add_gaussian_noise","text":"<pre><code>add_gaussian_noise(image: ImageType, mean: float = 0.0, std: float = 1.0, clip_to_max: bool = True) -&gt; ndarray\n</code></pre> Source code in <code>siapy/transformations/image.py</code> <pre><code>def add_gaussian_noise(\n    image: ImageType,\n    mean: float = 0.0,\n    std: float = 1.0,\n    clip_to_max: bool = True,\n) -&gt; np.ndarray:\n    image_np = validate_image_to_numpy(image)\n    rng = np.random.default_rng()\n    noise = rng.normal(loc=mean, scale=std, size=image_np.shape)\n    image_np = image_np + noise\n    if clip_to_max:\n        image_np = np.clip(image_np, 0, np.max(image_np))\n    return image_np\n</code></pre>"},{"location":"api/transformations/image/#siapy.transformations.image.random_crop","title":"random_crop","text":"<pre><code>random_crop(image: ImageType, output_size: ImageSizeType) -&gt; ndarray\n</code></pre> Source code in <code>siapy/transformations/image.py</code> <pre><code>def random_crop(image: ImageType, output_size: ImageSizeType) -&gt; np.ndarray:\n    image_np = validate_image_to_numpy(image)\n    output_size = validate_image_size(output_size)\n    h, w = image_np.shape[:2]\n    new_h, new_w = output_size\n    top = np.random.randint(0, h - new_h)\n    left = np.random.randint(0, w - new_w)\n    return image_np[top : top + new_h, left : left + new_w]\n</code></pre>"},{"location":"api/transformations/image/#siapy.transformations.image.random_mirror","title":"random_mirror","text":"<pre><code>random_mirror(image: ImageType) -&gt; ndarray\n</code></pre> Source code in <code>siapy/transformations/image.py</code> <pre><code>def random_mirror(image: ImageType) -&gt; np.ndarray:\n    image_np = validate_image_to_numpy(image)\n    axis = random.choices([0, 1, (0, 1), None])[0]\n    if isinstance(axis, int) or isinstance(axis, tuple):\n        image_np = np.flip(image_np, axis=axis)\n    return image_np\n</code></pre>"},{"location":"api/transformations/image/#siapy.transformations.image.random_rotation","title":"random_rotation","text":"<pre><code>random_rotation(image: ImageType, angle: float) -&gt; ndarray\n</code></pre> Source code in <code>siapy/transformations/image.py</code> <pre><code>def random_rotation(image: ImageType, angle: float) -&gt; np.ndarray:\n    image_np = validate_image_to_numpy(image)\n    rotated_image = transform.rotate(image_np, angle, preserve_range=True)\n    return rotated_image\n</code></pre>"},{"location":"api/transformations/image/#siapy.transformations.image.rescale","title":"rescale","text":"<pre><code>rescale(image: ImageType, output_size: ImageSizeType) -&gt; ndarray\n</code></pre> Source code in <code>siapy/transformations/image.py</code> <pre><code>def rescale(image: ImageType, output_size: ImageSizeType) -&gt; np.ndarray:\n    image_np = validate_image_to_numpy(image)\n    output_size = validate_image_size(output_size)\n    rescaled_image = transform.resize(image_np, output_size, preserve_range=True)\n    return rescaled_image\n</code></pre>"},{"location":"api/transformations/image/#siapy.transformations.image.area_normalization","title":"area_normalization","text":"<pre><code>area_normalization(image: ImageType) -&gt; ndarray\n</code></pre> Source code in <code>siapy/transformations/image.py</code> <pre><code>def area_normalization(image: ImageType) -&gt; np.ndarray:\n    image_np = validate_image_to_numpy(image)\n\n    def _signal_normalize(signal: np.ndarray) -&gt; np.ndarray:\n        area = np.trapz(signal)\n        if area == 0:\n            return signal\n        return signal / area\n\n    def _image_normalization(image_np: np.ndarray, func1d: Callable[[np.ndarray], np.ndarray]) -&gt; np.ndarray:\n        return np.apply_along_axis(func1d, axis=2, arr=image_np)\n\n    return _image_normalization(image_np, _signal_normalize)\n</code></pre>"},{"location":"api/utils/images/","title":"Images","text":""},{"location":"api/utils/images/#siapy.utils.images","title":"siapy.utils.images","text":""},{"location":"api/utils/images/#siapy.utils.images.save_image","title":"save_image","text":"<pre><code>save_image(image: ndarray, save_path: str | Path, *, metadata: dict[str, Any] | None = None, overwrite: bool = True, dtype: type[ImageDataType] = float32)\n</code></pre> Source code in <code>siapy/utils/images.py</code> <pre><code>def save_image(\n    image: Annotated[np.ndarray, \"The image to save.\"],\n    save_path: Annotated[str | Path, \"Header file (with '.hdr' extension) name with path.\"],\n    *,\n    metadata: Annotated[\n        dict[str, Any] | None,\n        \"A dict containing ENVI header parameters (e.g., parameters extracted from a source image).\",\n    ] = None,\n    overwrite: Annotated[\n        bool,\n        \"If the associated image file or header already exist and set to True, the files will be overwritten; otherwise, if either of the files exist, an exception will be raised.\",\n    ] = True,\n    dtype: Annotated[\n        type[ImageDataType],\n        \"The numpy data type with which to store the image.\",\n    ] = np.float32,\n):\n    if isinstance(save_path, str):\n        save_path = Path(save_path)\n    if metadata is None:\n        metadata = {}\n\n    os.makedirs(save_path.parent, exist_ok=True)\n    sp.envi.save_image(\n        hdr_file=save_path,\n        image=image,\n        dtype=dtype,\n        force=overwrite,\n        metadata=metadata,\n    )\n    logger.info(f\"Image saved as:  {save_path}\")\n</code></pre>"},{"location":"api/utils/images/#siapy.utils.images.create_image","title":"create_image","text":"<pre><code>create_image(image: ndarray, save_path: str | Path, *, metadata: dict[str, Any] | None = None, overwrite: bool = True, dtype: type[ImageDataType] = float32) -&gt; SpectralImage\n</code></pre> Source code in <code>siapy/utils/images.py</code> <pre><code>def create_image(\n    image: Annotated[np.ndarray, \"The image to save.\"],\n    save_path: Annotated[str | Path, \"Header file (with '.hdr' extension) name with path.\"],\n    *,\n    metadata: Annotated[\n        dict[str, Any] | None,\n        \"A dict containing ENVI header parameters (e.g., parameters extracted from a source image).\",\n    ] = None,\n    overwrite: Annotated[\n        bool,\n        \"If the associated image file or header already exist and set to True, the files will be overwritten; otherwise, if either of the files exist, an exception will be raised.\",\n    ] = True,\n    dtype: Annotated[\n        type[ImageDataType],\n        \"The numpy data type with which to store the image.\",\n    ] = np.float32,\n) -&gt; SpectralImage:\n    if isinstance(save_path, str):\n        save_path = Path(save_path)\n    if metadata is None:\n        metadata = {\n            \"lines\": image.shape[0],\n            \"samples\": image.shape[1],\n            \"bands\": image.shape[2],\n        }\n\n    os.makedirs(save_path.parent, exist_ok=True)\n    spectral_image = sp.envi.create_image(\n        hdr_file=save_path,\n        metadata=metadata,\n        dtype=dtype,\n        force=overwrite,\n    )\n    mmap = spectral_image.open_memmap(writable=True)\n    mmap[:, :, :] = image\n    logger.info(f\"Image created as:  {save_path}\")\n    return SpectralImage(SpectralLibImage(spectral_image))\n</code></pre>"},{"location":"api/utils/images/#siapy.utils.images.merge_images_by_specter","title":"merge_images_by_specter","text":"<pre><code>merge_images_by_specter(*, image_original: SpectralImage, image_to_merge: SpectralImage, save_path: str | Path, overwrite: bool = True, dtype: type[ImageDataType] = float32, auto_metadata_extraction: bool = True)\n</code></pre> Source code in <code>siapy/utils/images.py</code> <pre><code>def merge_images_by_specter(\n    *,\n    image_original: Annotated[SpectralImage, \"Original image.\"],\n    image_to_merge: Annotated[SpectralImage, \"Image which will be merged onto original image.\"],\n    save_path: Annotated[str | Path, \"Header file (with '.hdr' extension) name with path.\"],\n    overwrite: Annotated[\n        bool,\n        \"If the associated image file or header already exist and set to True, the files will be overwritten; otherwise, if either of the files exist, an exception will be raised.\",\n    ] = True,\n    dtype: Annotated[\n        type[ImageDataType],\n        \"The numpy data type with which to store the image.\",\n    ] = np.float32,\n    auto_metadata_extraction: Annotated[\n        bool,\n        \"Whether to automatically extract metadata images.\",\n    ] = True,\n):\n    image_original_np = image_original.to_numpy()\n    image_to_merge_np = image_to_merge.to_numpy()\n\n    metadata = {\n        \"lines\": image_original.shape[0],\n        \"samples\": image_original.shape[1],\n        \"bands\": image_original.shape[2] + image_to_merge.shape[2],\n    }\n    if auto_metadata_extraction:\n        original_meta = image_original.metadata\n        merged_meta = image_to_merge.metadata\n        metadata_ext = {}\n\n        metadata_ext[\"wavelength\"] = original_meta.get(\"wavelength\", []) + merged_meta.get(\"wavelength\", [])\n        metadata_ext[\"data type\"] = original_meta.get(\"data type\", \"\")\n        metadata_ext[\"byte order\"] = original_meta.get(\"byte order\", \"\")\n        metadata_ext[\"data ignore value\"] = original_meta.get(\"data ignore value\", \"\")\n        metadata_ext[\"header offset\"] = original_meta.get(\"header offset\", 0)\n        metadata_ext[\"interleave\"] = original_meta.get(\"interleave\", \"\")\n        metadata_ext[\"wavelength units\"] = original_meta.get(\"wavelength units\", \"\")\n        metadata_ext[\"acquisition date\"] = original_meta.get(\"acquisition date\", \"\")\n\n        metadata_ext[\"default bands\"] = original_meta.get(\"default bands\", [])\n        metadata_ext[\"default bands additional\"] = merged_meta.get(\"default bands\", [])\n        metadata_ext[\"description\"] = original_meta.get(\"description\", \"\")\n        # metadata_ext[\"description additional\"] = merged_meta.get(\"description\", \"\")\n\n        metadata.update(metadata_ext)\n\n    image_to_merge_np = rescale(\n        image_to_merge_np,\n        (image_original_np.shape[0], image_original_np.shape[1]),\n    )\n    image_to_merge_np = image_to_merge_np.astype(image_original_np.dtype)\n    image_merged = np.concatenate((image_original_np, image_to_merge_np), axis=2)\n\n    return create_image(\n        image=image_merged,\n        save_path=save_path,\n        metadata=metadata,\n        overwrite=overwrite,\n        dtype=dtype,\n    )\n</code></pre>"},{"location":"api/utils/images/#siapy.utils.images.convert_radiance_image_to_reflectance","title":"convert_radiance_image_to_reflectance","text":"<pre><code>convert_radiance_image_to_reflectance(image: SpectralImage, panel_correction: ndarray, save_path: str | Path | None = None, **kwargs: Any) -&gt; ndarray | SpectralImage\n</code></pre> Source code in <code>siapy/utils/images.py</code> <pre><code>def convert_radiance_image_to_reflectance(\n    image: SpectralImage,\n    panel_correction: np.ndarray,\n    save_path: Annotated[str | Path | None, \"Header file (with '.hdr' extension) name with path.\"] = None,\n    **kwargs: Any,\n) -&gt; np.ndarray | SpectralImage:\n    image_ref_np = image.to_numpy() * panel_correction\n    if save_path is None:\n        return image_ref_np\n\n    return create_image(\n        image=image_ref_np,\n        save_path=save_path,\n        metadata=image.metadata,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/utils/images/#siapy.utils.images.calculate_correction_factor_from_panel","title":"calculate_correction_factor_from_panel","text":"<pre><code>calculate_correction_factor_from_panel(image: SpectralImage, panel_reference_reflectance: float, panel_shape_label: str | None = None) -&gt; ndarray\n</code></pre> Source code in <code>siapy/utils/images.py</code> <pre><code>def calculate_correction_factor_from_panel(\n    image: SpectralImage,\n    panel_reference_reflectance: float,\n    panel_shape_label: str | None = None,\n) -&gt; np.ndarray:\n    if panel_shape_label:\n        panel_shape = image.geometric_shapes.get_by_name(panel_shape_label)\n        if not panel_shape:\n            raise InvalidInputError(\n                input_value={\"panel_shape_label\": panel_shape_label},\n                message=\"Panel shape label not found.\",\n            )\n        if len(panel_shape) != 1:\n            raise InvalidInputError(\n                input_value={\"panel_shape\": panel_shape},\n                message=\"Panel shape label must refer to a single shape.\",\n            )\n        pixels_hull = panel_shape.get_pixels_within_convex_hull()[0].as_type(int)\n        panel_signatures = image.to_signatures(pixels_hull)\n        panel_radiance_mean = panel_signatures.signals.mean()\n\n    else:\n        temp_mean = image.mean(axis=(0, 1))\n        if not isinstance(temp_mean, np.ndarray):\n            raise InvalidInputError(\n                input_value={\"image\": image},\n                message=f\"Expected image.mean(axis=(0, 1)) to return np.ndarray, but got {type(temp_mean).__name__}.\",\n            )\n        panel_radiance_mean = temp_mean\n\n    panel_reflectance_mean = np.full(image.bands, panel_reference_reflectance)\n    panel_correction = panel_reflectance_mean / panel_radiance_mean\n    return panel_correction\n</code></pre>"},{"location":"api/utils/images/#siapy.utils.images.blockfy_image","title":"blockfy_image","text":"<pre><code>blockfy_image(image: ImageType, p: int, q: int) -&gt; list[ndarray]\n</code></pre> Source code in <code>siapy/utils/images.py</code> <pre><code>def blockfy_image(\n    image: ImageType,\n    p: Annotated[int, \"block row size\"],\n    q: Annotated[int, \"block column size\"],\n) -&gt; list[np.ndarray]:\n    image_np = validate_image_to_numpy(image)\n    # Calculate how many blocks can cover the entire image\n    bpr = (image_np.shape[0] - 1) // p + 1  # blocks per row\n    bpc = (image_np.shape[1] - 1) // q + 1  # blocks per column\n\n    # Pad array with NaNs so it can be divided by p row-wise and by q column-wise\n    image_pad = np.nan * np.ones([p * bpr, q * bpc, image_np.shape[2]])\n    image_pad[: image_np.shape[0], : image_np.shape[1], : image_np.shape[2]] = image_np\n\n    image_slices = []\n    row_prev = 0\n\n    for row_block in range(bpc):\n        row_prev = row_block * p\n        column_prev = 0\n\n        for column_block in range(bpr):\n            column_prev = column_block * q\n            block = image_pad[\n                row_prev : row_prev + p,\n                column_prev : column_prev + q,\n            ]\n\n            if block.shape == (p, q, image_np.shape[2]):\n                image_slices.append(block)\n\n    return image_slices\n</code></pre>"},{"location":"api/utils/images/#siapy.utils.images.calculate_image_background_percentage","title":"calculate_image_background_percentage","text":"<pre><code>calculate_image_background_percentage(image: ImageType)\n</code></pre> Source code in <code>siapy/utils/images.py</code> <pre><code>def calculate_image_background_percentage(image: ImageType):\n    image_np = validate_image_to_numpy(image)\n    # Check where any of bands include nan values (axis=2) to get positions of background\n    mask_nan = np.any(np.isnan(image_np), axis=2)\n    # Calculate percentage of background\n    percentage = np.sum(mask_nan) / mask_nan.size * 100\n    return percentage\n</code></pre>"},{"location":"api/utils/plots/","title":"Plots","text":""},{"location":"api/utils/plots/#siapy.utils.plots","title":"siapy.utils.plots","text":""},{"location":"api/utils/plots/#siapy.utils.plots.InteractiveButtonsEnum","title":"InteractiveButtonsEnum","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/utils/plots/#siapy.utils.plots.InteractiveButtonsEnum.SAVE","title":"SAVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SAVE = auto()\n</code></pre>"},{"location":"api/utils/plots/#siapy.utils.plots.InteractiveButtonsEnum.REPEAT","title":"REPEAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPEAT = auto()\n</code></pre>"},{"location":"api/utils/plots/#siapy.utils.plots.InteractiveButtonsEnum.SKIP","title":"SKIP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SKIP = auto()\n</code></pre>"},{"location":"api/utils/plots/#siapy.utils.plots.pixels_select_click","title":"pixels_select_click","text":"<pre><code>pixels_select_click(image: ImageType) -&gt; Pixels\n</code></pre> Source code in <code>siapy/utils/plots.py</code> <pre><code>def pixels_select_click(image: ImageType) -&gt; Pixels:\n    image_display = validate_image_to_numpy_3channels(image)\n\n    coordinates = []\n    fig, ax = plt.subplots(1, 1)\n    ax.imshow(image_display)\n    fig.tight_layout()\n    enter_clicked = 0\n\n    def onclick(event):\n        nonlocal coordinates, fig\n        logger.info(f\"Pressed coordinate: X = {event.xdata}, Y = {event.ydata}\")\n        x_coor = round(event.xdata)\n        y_coor = round(event.ydata)\n        coordinates.append([x_coor, y_coor])\n\n        ax.scatter(\n            int(x_coor),\n            int(y_coor),\n            marker=\"x\",\n            c=\"red\",\n        )\n        fig.canvas.draw()\n\n    def accept(event):\n        nonlocal enter_clicked\n        if event.key == \"enter\":\n            logger.info(\"Enter clicked.\")\n            enter_clicked = 1\n            plt.close()\n\n    def onexit(event):\n        nonlocal enter_clicked\n        if not enter_clicked:\n            logger.info(\"Exiting application.\")\n            plt.close()\n            sys.exit(0)\n\n    fig.canvas.mpl_connect(\"button_press_event\", onclick)\n    fig.canvas.mpl_connect(\"key_press_event\", accept)\n    fig.canvas.mpl_connect(\"close_event\", onexit)\n    plt.show()\n    return Pixels.from_iterable(coordinates)\n</code></pre>"},{"location":"api/utils/plots/#siapy.utils.plots.pixels_select_lasso","title":"pixels_select_lasso","text":"<pre><code>pixels_select_lasso(image: ImageType, selector_props: dict[str, Any] | None = None) -&gt; list[Pixels]\n</code></pre> Source code in <code>siapy/utils/plots.py</code> <pre><code>def pixels_select_lasso(image: ImageType, selector_props: dict[str, Any] | None = None) -&gt; list[Pixels]:\n    image_display = validate_image_to_numpy_3channels(image)\n\n    x, y = np.meshgrid(np.arange(image_display.shape[1]), np.arange(image_display.shape[0]))\n    pixes_all_stack = np.vstack((x.flatten(), y.flatten())).T\n\n    fig, ax = plt.subplots(1, 1)\n    ax.imshow(image_display)\n    fig.tight_layout()\n\n    indices = 0\n    indices_list = []\n    enter_clicked = 0\n\n    def onselect(vertices_selected, eps=1e-8):\n        logger.info(\"Selected.\")\n        nonlocal indices\n        path = Path(vertices_selected)\n        indices = path.contains_points(pixes_all_stack)\n\n    def onrelease(_):\n        nonlocal indices, indices_list\n        indices_list.append(indices)\n\n    def onexit(event):\n        nonlocal enter_clicked\n        if not enter_clicked:\n            logger.info(\"Exiting application.\")\n            plt.close()\n            sys.exit(0)\n\n    def accept(event):\n        nonlocal enter_clicked\n        if event.key == \"enter\":\n            logger.info(\"Enter clicked.\")\n            enter_clicked = 1\n            plt.close()\n\n    props = selector_props if selector_props is not None else {\"color\": \"red\", \"linewidth\": 2, \"linestyle\": \"-\"}\n    lasso = LassoSelector(ax, onselect, props=props)  # noqa: F841\n    fig.canvas.mpl_connect(\"button_release_event\", onrelease)\n    fig.canvas.mpl_connect(\"close_event\", onexit)\n    fig.canvas.mpl_connect(\"key_press_event\", accept)\n\n    plt.show()\n\n    selected_areas = []\n    for indices in indices_list:\n        coordinates = pixes_all_stack[indices]\n        selected_areas.append(Pixels.from_iterable(coordinates))\n\n    logger.info(f\"Number of selected areas: {len(selected_areas)}\")\n    return selected_areas\n</code></pre>"},{"location":"api/utils/plots/#siapy.utils.plots.display_image_with_areas","title":"display_image_with_areas","text":"<pre><code>display_image_with_areas(image: ImageType, areas: Pixels | list[Pixels], *, color: str = 'red')\n</code></pre> Source code in <code>siapy/utils/plots.py</code> <pre><code>def display_image_with_areas(\n    image: ImageType,\n    areas: Pixels | list[Pixels],\n    *,\n    color: str = \"red\",\n):\n    if not isinstance(areas, list):\n        areas = [areas]\n\n    image_display = validate_image_to_numpy_3channels(image)\n    fig, ax = plt.subplots()\n    ax.imshow(image_display)\n\n    for pixels in areas:\n        ax.scatter(\n            pixels.u(),\n            pixels.v(),\n            lw=0,\n            marker=\"o\",\n            c=color,\n            s=(72.0 / fig.dpi) ** 2,\n        )\n\n    plt.show()\n</code></pre>"},{"location":"api/utils/plots/#siapy.utils.plots.display_multiple_images_with_areas","title":"display_multiple_images_with_areas","text":"<pre><code>display_multiple_images_with_areas(images_with_areas: list[tuple[ImageType, Pixels | list[Pixels]]], *, color: str = 'red', plot_interactive_buttons: bool = True) -&gt; InteractiveButtonsEnum | None\n</code></pre> Source code in <code>siapy/utils/plots.py</code> <pre><code>def display_multiple_images_with_areas(\n    images_with_areas: list[tuple[ImageType, Pixels | list[Pixels]]],\n    *,\n    color: str = \"red\",\n    plot_interactive_buttons: bool = True,\n) -&gt; InteractiveButtonsEnum | None:\n    num_images = len(images_with_areas)\n    fig, axes = plt.subplots(1, num_images, figsize=(num_images * 5, 5))\n\n    if isinstance(axes, Axes):\n        axes = np.array([axes])\n\n    for ax, (image, selected_areas) in zip(axes, images_with_areas):\n        if not isinstance(selected_areas, list):\n            selected_areas = [selected_areas]\n\n        image_display = validate_image_to_numpy_3channels(image)\n        ax.imshow(image_display)\n\n        for pixels in selected_areas:\n            ax.scatter(\n                pixels.u(),\n                pixels.v(),\n                lw=0,\n                marker=\"o\",\n                c=color,\n                s=(72.0 / fig.dpi) ** 2,\n            )\n    if plot_interactive_buttons:\n        return interactive_buttons()\n\n    plt.show()\n    return None\n</code></pre>"},{"location":"api/utils/plots/#siapy.utils.plots.interactive_buttons","title":"interactive_buttons","text":"<pre><code>interactive_buttons()\n</code></pre> Source code in <code>siapy/utils/plots.py</code> <pre><code>def interactive_buttons():\n    flag = InteractiveButtonsEnum.REPEAT\n\n    def repeat(event):\n        nonlocal flag\n        logger.info(\"Pressed repeat button.\")\n        plt.close()\n        flag = InteractiveButtonsEnum.REPEAT\n\n    def save(event):\n        nonlocal flag\n        logger.info(\"Pressed save button.\")\n        plt.close()\n        flag = InteractiveButtonsEnum.SAVE\n\n    def skip(event):\n        nonlocal flag\n        logger.info(\"Pressed skip button.\")\n        plt.close()\n        flag = InteractiveButtonsEnum.SKIP\n\n    axcolor = \"lightgoldenrodyellow\"\n    position = plt.axes((0.9, 0.1, 0.1, 0.04))\n    button_save = Button(position, \"Save\", color=axcolor, hovercolor=\"0.975\")\n    button_save.on_clicked(save)\n    position = plt.axes((0.9, 0.15, 0.1, 0.04))\n    button_repeat = Button(position, \"Repeat\", color=axcolor, hovercolor=\"0.975\")\n    button_repeat.on_clicked(repeat)\n    position = plt.axes((0.9, 0.2, 0.1, 0.04))\n    button_skip = Button(position, \"Skip\", color=axcolor, hovercolor=\"0.975\")\n    button_skip.on_clicked(skip)\n    plt.show()\n    return flag\n</code></pre>"},{"location":"api/utils/plots/#siapy.utils.plots.display_signals","title":"display_signals","text":"<pre><code>display_signals(data: TabularDatasetData, *, figsize: tuple[int, int] = (6, 4), dpi: int = 150, colormap: str = 'viridis', x_label: str = 'Spectral bands', y_label: str = '', label_fontsize: int = 14, tick_params_label_size: int = 12, legend_fontsize: int = 10, legend_frameon: bool = True)\n</code></pre> Source code in <code>siapy/utils/plots.py</code> <pre><code>def display_signals(\n    data: TabularDatasetData,\n    *,\n    figsize: tuple[int, int] = (6, 4),\n    dpi: int = 150,\n    colormap: str = \"viridis\",\n    x_label: str = \"Spectral bands\",\n    y_label: str = \"\",\n    label_fontsize: int = 14,\n    tick_params_label_size: int = 12,\n    legend_fontsize: int = 10,\n    legend_frameon: bool = True,\n):\n    if not isinstance(data.target, ClassificationTarget):\n        raise InvalidInputError(\n            input_value=data.target,\n            message=\"The target must be an instance of ClassificationTarget.\",\n        )\n\n    signals = data.signals.copy()\n    target = data.target.model_copy()\n    y_data_encoded = target.value\n    classes = list(target.encoding.to_dict().values())\n\n    fig, ax = plt.subplots(figsize=figsize, dpi=dpi)\n    cmap = plt.get_cmap(colormap)\n    unique_labels = np.unique(y_data_encoded)\n    no_colors = len(unique_labels)\n\n    if no_colors &gt; 2:\n        colors = list(cmap(np.linspace(0, 1, no_colors)))\n    else:\n        colors = [\"darkgoldenrod\", \"forestgreen\"]\n\n    x_values = list(range(len(signals.columns)))\n\n    grouped_data = signals.groupby(y_data_encoded.to_numpy())\n    mean_values = grouped_data.mean()\n    std_values = grouped_data.std()\n\n    for idx in unique_labels:\n        mean = mean_values.loc[idx].tolist()\n        std = std_values.loc[idx].tolist()\n        ax.plot(x_values, mean, color=colors[idx], label=classes[idx], alpha=0.6)\n        ax.fill_between(\n            x_values,\n            [m - s for m, s in zip(mean, std)],\n            [m + s for m, s in zip(mean, std)],\n            color=colors[idx],\n            alpha=0.2,\n        )\n\n    custom_lines = []\n    for idx in unique_labels:\n        custom_lines.append(Line2D([0], [0], color=colors[idx], lw=2))\n\n    ax.set_ylabel(y_label, fontsize=label_fontsize)\n    ax.set_xlabel(x_label, fontsize=label_fontsize)\n    ax.tick_params(axis=\"both\", which=\"major\", labelsize=tick_params_label_size)\n    ax.tick_params(axis=\"both\", which=\"minor\", labelsize=tick_params_label_size)\n    # ax.set_ylim([0, 1])\n    # ax.spines[\"bottom\"].set_linewidth(2)\n    # ax.spines[\"left\"].set_linewidth(2)\n    ax.spines[\"right\"].set_linewidth(0)\n    ax.spines[\"top\"].set_linewidth(0)\n    ax.set_xticks(x_values)\n    ax.set_xticklabels(signals.columns, rotation=0)\n    ax.legend(\n        loc=\"upper left\",\n        fontsize=legend_fontsize,\n        framealpha=1,\n        frameon=legend_frameon,\n    )\n    plt.show()\n</code></pre>"},{"location":"examples/introduction/","title":"Introduction","text":"<p>This section provides an overview of key concepts and functionalities of the SiaPy library. You can find code snippets here.</p> <p>To follow along with the examples, please download the example data from Zenodo and install the library by following the installation instructions.</p>"},{"location":"examples/introduction/#data-used-in-examples","title":"\ud83d\udcc4 Data used in examples","text":"<p>The hyperspectral images were acquired using Hyspex push-broom cameras from Norsk Elektro Optikk (Oslo, Norway). Two spectral regions were covered:</p> <ul> <li>VNIR-1600: Visible to near-infrared (400\u2013988 nm) with 160 bands and a bandwidth of 3.6 nm.</li> <li>SWIR-384: Short-wave infrared (950\u20132500 nm) with 288 bands and a bandwidth of 5.4 nm.</li> </ul> <p>The acquired hyperspectral data, expressed as reflectance values, were already radiometrically calibrated to ensure accuracy and reliability for subsequent analysis.</p> <p>Description of file names</p> File Name Description L1_L2_L3__test__ID_CAM.img Image file L1_L2_L3__test__ID_CAM.hdr Header file corresponding to the image file Component Description L Labels of plants in the image ID Random ID assigned when the image is acquired CAM Camera type; <code>corr</code> for VNIR, <code>corr2</code> for SWIR Labels Example V-T-N KK-K-04 Component Description V Variety <code>KK</code>: KIS Krka <code>KS</code>: KIS Savinja T Treatment <code>K</code>: Control <code>S</code>: Drought N Index of a particular plant"},{"location":"examples/introduction/#validation-of-setup","title":"\ud83d\ude80 Validation of setup","text":"<p>To verify that the data and the SiaPy installation meet the expected requirements, run the following code snippet. It should print a message indicating whether the loading was successful.</p> <pre><code>try:\n    from pathlib import Path\n\n    from siapy.entities import SpectralImageSet\n\n    print(\"Libraries detected successfully.\")\nexcept ImportError as e:\n    print(f\"Error: {e}. Please ensure that the SiaPy library is installed and the environment is activated.\")\n    exit(1)\n\n# Set the path to the directory containing the data\n# !! ADJUST THIS PATH TO YOUR DATA DIRECTORY !!\ndata_dir = \"./docs/examples/data\"\n\n# Find all header and image files in the data directory\nheader_paths = sorted(Path(data_dir).rglob(\"*.hdr\"))\nimage_paths = sorted(Path(data_dir).rglob(\"*.img\"))\n\n# Create a SpectralImageSet from the found paths\nimage_set = SpectralImageSet.spy_open(\n    header_paths=header_paths,\n    image_paths=image_paths,\n)\n\n# Check if the data was loaded correctly\nif len(image_set) &gt; 0:\n    print(\"Loading succeeded.\")\nelse:\n    print(\"Loading did not succeed.\")\n</code></pre> <p>Warning</p> <p>If the <code>SiaPy</code> library is not installed or the environment is not activated, an error will be thrown at the import statement. Additionally, if the data images are not present, the code will generate an empty image set, resulting in the script printing that the loading was not successful. Make sure to change <code>data_dir</code> to point to the directory where the images are stored.</p>"},{"location":"examples/spectral_image/","title":"Spectral Image","text":"<p>This example demonstrates how to load and inspect a spectral image using the SiaPy library:</p> <ul> <li>Load a spectral image.</li> <li>Access various properties and metadata.</li> </ul> <pre><code>from pathlib import Path\n\nimport spectral as sp\n\nfrom siapy.entities import SpectralImage\nfrom siapy.entities.images import SpectralLibImage\n\n# Set the path to the directory containing the data\n# !! ADJUST THIS PATH TO YOUR DATA DIRECTORY !!\ndata_dir = \"./docs/examples/data\"\n\n# Find all header and image files in the data directory\nheader_paths = sorted(Path(data_dir).rglob(\"*.hdr\"))\nimage_paths = sorted(Path(data_dir).rglob(\"*.img\"))\n\nheader_path_img0 = header_paths[0]\nimage_path_img0 = image_paths[0]\n\n# Load the image using spectral library and then wrap over SpectralImage object\nsp_file = sp.envi.open(file=header_path_img0, image=image_path_img0)\nassert not isinstance(sp_file, sp.io.envi.SpectralLibrary)\nimage = SpectralImage(SpectralLibImage(sp_file))\n\n# or you can do the same just by running\nimage = SpectralImage.spy_open(\n    header_path=header_path_img0,\n    image_path=image_path_img0,\n)\n\n# Now you can easily use various property and util functions of the SpectralImage object\n# Get the shape of the image\nprint(\"Image shape:\", image.shape)\n\n# Get the number of bands\nprint(\"Number of bands:\", image.bands)\n\n# Get the wavelength information\nprint(\"Wavelengths:\", image.wavelengths)\n\n# Get the file path\nprint(\"File path:\", image.filepath)\n\n# Get the metadata\nprint(\"Metadata:\", image.metadata)\n\n# Get the number of rows\nprint(\"Number of rows:\", image.image.rows)\n\n# Get the number of columns\nprint(\"Number of columns:\", image.image.cols)\n\n# Get the default bands\nprint(\"Default bands:\", image.default_bands)\n\n# Get the description\nprint(\"Description:\", image.image.description)\n\n# Get the camera ID\nprint(\"Camera ID:\", image.camera_id)\n\n# Get the geometric shapes\nprint(\"Geometric shapes:\", image.geometric_shapes)\n</code></pre> <p>Source: <code>spectral_image_01.py</code></p> <p>This example demonstrates how to perform various operations on a spectral image:</p> <ul> <li>Convert a spectral image to a NumPy array.</li> <li>Calculate the mean value per band.</li> <li>Create a <code>Pixels</code> object from pixel coordinates.</li> <li>Extract spectral signatures and subarrays.</li> <li>Display the spectral image.</li> </ul> <pre><code>from pathlib import Path\n\nimport matplotlib.pyplot as plt\n\nfrom siapy.entities import Pixels, SpectralImage\n\n# Set the path to the directory containing the data\n# !! ADJUST THIS PATH TO YOUR DATA DIRECTORY !!\ndata_dir = \"./docs/examples/data\"\n\n# Get first image\nheader_path_img0 = sorted(Path(data_dir).rglob(\"*.hdr\"))[1]\nimage_path_img0 = sorted(Path(data_dir).rglob(\"*.img\"))[1]\n\n# Load spectral image\nimage = SpectralImage.spy_open(\n    header_path=header_path_img0,\n    image_path=image_path_img0,\n)\n\n# Convert to numpy\nimage_np = image.to_numpy(nan_value=0.0)\nprint(\"Image shape:\", image_np.shape)\n\n# Calculate mean\nmean_val = image.mean(axis=(0, 1))\nprint(\"Mean value per band:\", mean_val)\n\n# Create a Pixels object from an iterable with pixels coordinates\n# The iterable should be a list of tuples representing (x, y) coordinates\n# iterable == [(x1, y1), (x2, y2), ...] -&gt; list of pixels\niterable = [(1, 2), (3, 4), (5, 6)]\npixels = Pixels.from_iterable(iterable)\n\n# Convert the pixel coordinates to spectral signatures\nsignatures = image.to_signatures(pixels)\nprint(\"Signatures:\", signatures)\n\n# Extract a subarray from the image using the pixel coordinates\nsubarray = image.to_subarray(pixels)\nprint(\"Subarray shape:\", subarray.shape)\n\n# Convert to displayable image\ndisplay_image = image.to_display(equalize=True)\n\n# Display the image using matplotlib\nplt.figure()\nplt.imshow(display_image)\nplt.axis(\"off\")  # Hide axes for better visualization\nplt.show()\n</code></pre> <p>Source: <code>spectral_image_02.py</code></p>"},{"location":"examples/spectral_imageset/","title":"Spectral Image Set","text":"<p>This example demonstrates how to perform various operations on a spectral image set:</p> <ul> <li>Load a set of spectral images.</li> <li>Sort the spectral images.</li> <li>Get the number of images in the set.</li> <li>Retrieve the camera IDs.</li> <li>Iterate over images and print their shapes.</li> <li>Get images by camera ID.</li> </ul> <pre><code>from pathlib import Path\n\nfrom siapy.entities import SpectralImageSet\n\n# Set the path to the directory containing the data\n# !! ADJUST THIS PATH TO YOUR DATA DIRECTORY !!\ndata_dir = \"./docs/examples/data\"\n\n# Find all header and image files in the data directory\nheader_paths = sorted(Path(data_dir).rglob(\"*.hdr\"))\nimage_paths = sorted(Path(data_dir).rglob(\"*.img\"))\n\n# Create a SpectralImageSet from the found paths\nimageset = SpectralImageSet.spy_open(\n    header_paths=header_paths,\n    image_paths=image_paths,\n)\n\n# Now you can easily use various properties and utility functions of the SpectralImageSet object.\n# First, let's sort the images:\nprint(\"Unsorted: \", imageset.images)\nimageset.sort()\nprint(\"Sorted: \", imageset.images)\n\n# Get the number of images in the set\nprint(\"Number of images in the set:\", len(imageset))\n\n# Get the cameras ID\nprint(\"Cameras ID:\", imageset.cameras_id)\n\n# Iterate over images and print their shapes\nfor idx, image in enumerate(imageset):\n    print(f\"Image {idx} shape:\", image.shape)\n\n# Get images by camera ID\ncamera_id = imageset.cameras_id[0]\nimages_by_camera = imageset.images_by_camera_id(camera_id)\nprint(f\"Number of images by camera {camera_id}:\", len(images_by_camera))\n</code></pre> <p>Source: <code>spectral_imageset_01.py</code></p>"},{"location":"examples/transformations/","title":"Transformations","text":"<p>This example demonstrates how to perform various transformations on spectral images:</p> <ul> <li>Select corresponding pixels in VNIR and SWIR images.</li> <li>Calculate the transformation matrix.</li> </ul> <pre><code>from pathlib import Path\n\nfrom siapy.entities import SpectralImage\nfrom siapy.transformations import corregistrator\nfrom siapy.utils.plots import pixels_select_click\n\n# Set the path to the directory containing the data\n# !! ADJUST THIS PATH TO YOUR DATA DIRECTORY !!\ndata_dir = \"./docs/examples/data\"\n\n# Get first image\nheader_path_img0 = sorted(Path(data_dir).rglob(\"coregister*corr2_rad_f32.hdr\"))[0]\nimage_path_img0 = sorted(Path(data_dir).rglob(\"coregister*corr2_rad_f32.img\"))[0]\nheader_path_img1 = sorted(Path(data_dir).rglob(\"coregister*corr_rad_f32.hdr\"))[0]\nimage_path_img1 = sorted(Path(data_dir).rglob(\"coregister*corr_rad_f32.img\"))[0]\n\n# Load VNIR and SWIR spectral images\nimage_swir = SpectralImage.spy_open(\n    header_path=header_path_img0,\n    image_path=image_path_img0,\n)\nimage_vnir = SpectralImage.spy_open(\n    header_path=header_path_img1,\n    image_path=image_path_img1,\n)\n\n# Select the same pixels in both images.\n# The more points you select, the better the transformation between image spaces will be.\n# Click enter to finish the selection.\npixels_vnir = pixels_select_click(image_vnir)\npixels_swir = pixels_select_click(image_swir)\n\n# Perform the transformation and transform the selected pixels from the VNIR image to the space of the SWIR image.\nmatx, _ = corregistrator.align(pixels_swir, pixels_vnir, plot_progress=False)\nprint(\"Transformation matrix:\", matx)\n</code></pre> <p>Source: <code>transformations_01.py</code></p> <p>This example demonstrates how to apply the calculated transformation matrix to spectral images:</p> <ul> <li>Select areas on VNIR image.</li> <li>Apply the transformation matrix to the selected areas.</li> <li>Transform the selected pixels from VNIR to SWIR space.</li> <li>Display both images with areas.</li> </ul> <pre><code>from pathlib import Path\n\nimport numpy as np\n\nfrom siapy.entities import SpectralImage\nfrom siapy.transformations import corregistrator\nfrom siapy.utils.plots import display_multiple_images_with_areas, pixels_select_lasso\n\n# Set the path to the directory containing the data\n# !! ADJUST THIS PATH TO YOUR DATA DIRECTORY !!\ndata_dir = \"./docs/examples/data\"\n\n# Get first image\nheader_path_img0 = sorted(Path(data_dir).rglob(\"*.hdr\"))[0]\nimage_path_img0 = sorted(Path(data_dir).rglob(\"*.img\"))[0]\nheader_path_img1 = sorted(Path(data_dir).rglob(\"*.hdr\"))[1]\nimage_path_img1 = sorted(Path(data_dir).rglob(\"*.img\"))[1]\n\n# Load VNIR and SWIR spectral images\nimage_swir = SpectralImage.spy_open(\n    header_path=header_path_img0,\n    image_path=image_path_img0,\n)\nimage_vnir = SpectralImage.spy_open(\n    header_path=header_path_img1,\n    image_path=image_path_img1,\n)\n\n# Transformation matrix was calculated in previous example\nmatx = np.array(\n    [\n        [5.10939099e-01, -3.05286868e-03, -1.48283389e00],\n        [-2.15777211e-03, 5.17836773e-01, -2.50694723e01],\n        [3.02412467e-18, 7.36518494e-18, 1.00000000e00],\n    ]\n)\n\n# Select area of the image\n# Click enter to finish the selection.\nselected_areas_vnir = pixels_select_lasso(image_vnir)\n\n# Transform the selected areas from the VNIR image to the space of the SWIR image.\nselected_areas_swir = [corregistrator.transform(pixels_vnir, matx) for pixels_vnir in selected_areas_vnir]\n\n# Display the selected areas in both images\ndisplay_multiple_images_with_areas(\n    [\n        (image_vnir, selected_areas_vnir),\n        (image_swir, selected_areas_swir),\n    ],\n    plot_interactive_buttons=False,\n)\n</code></pre> <p>Source: <code>transformations_02.py</code></p> <p>This example demonstrates how to apply various image transformations:</p> <ul> <li>Add Gaussian noise to the image.</li> <li>Perform random cropping.</li> <li>Apply random mirroring.</li> <li>Rotate the image randomly.</li> <li>Rescale the image.</li> <li>Normalize the image area.</li> </ul> <pre><code>from pathlib import Path\n\nfrom siapy.entities import SpectralImage\nfrom siapy.transformations.image import (\n    add_gaussian_noise,\n    area_normalization,\n    random_crop,\n    random_mirror,\n    random_rotation,\n    rescale,\n)\n\n# Set the path to the directory containing the data\n# !! ADJUST THIS PATH TO YOUR DATA DIRECTORY !!\ndata_dir = \"./docs/examples/data\"\n\n# Get first image\nheader_path_img0 = sorted(Path(data_dir).rglob(\"*.hdr\"))[0]\nimage_path_img0 = sorted(Path(data_dir).rglob(\"*.img\"))[0]\n\n# Load VNIR and SWIR spectral images\nimage_swir = SpectralImage.spy_open(\n    header_path=header_path_img0,\n    image_path=image_path_img0,\n)\n\n# Convert image to numpy array\nimage_swir_np = image_swir.to_numpy()\n\n# Apply transformations to image_swir\n# Add Gaussian noise\nnoisy_image = add_gaussian_noise(image_swir_np, mean=0.0, std=1.0, clip_to_max=True)\n\n# Random crop\ncropped_image = random_crop(image_swir_np, output_size=(100, 100))\n\n# Random mirror\nmirrored_image = random_mirror(image_swir_np)\n\n# Random rotation\nrotated_image = random_rotation(image_swir_np, angle=45)\n\n# Rescale\nrescaled_image = rescale(image_swir_np, output_size=(200, 200))\n\n# Area normalization\nnormalized_image = area_normalization(image_swir_np)\n</code></pre> <p>Source: <code>transformations_03.py</code></p>"},{"location":"examples/use_cases/","title":"Use cases","text":"<p>The functionality of the SiaPy library has been implemented in various use cases, demonstrating its capabilities and potential applications. The library's functionality is not limited to these examples and can be extended to other applications as well.</p>"},{"location":"examples/use_cases/#siapy-command-line-tool-cli","title":"\ud83d\ude80 SiaPy command line tool (CLI)","text":"<p>To facilitate the use of some of the SiaPy library's functionality, a command line interface (CLI) has been implemented.</p> <p>The CLI currently supports the following commands:</p> <ul> <li>Display images from two cameras.</li> <li>Co-register cameras and compute the transformation from one camera's space to another.</li> <li>Select regions in images for training machine learning (ML) models.</li> <li>Perform image segmentation using a pre-trained ML model.</li> <li>Convert radiance images to reflectance by utilizing a reference panel.</li> <li>Display spectral signatures for in-depth analysis.</li> </ul> <p>Info</p> <p>\ud83d\udcbb Code Repository</p>"},{"location":"examples/use_cases/#hyperspectral-data-utilization-in-research","title":"\ud83d\ude80 Hyperspectral data utilization in research","text":"<p>This use case demonstrates how to utilize extracted data from hyperspectral images in research. The project integrates a machine learning (ML) pipeline workflow with the SiaPy library to classify spectral signatures.</p> <p>Key features:</p> <ul> <li>Provides a structured approach to train and test models.</li> <li>Features an integrated modular architecture for easy modification of models and data.</li> <li>Includes an optimization process with hyperparameter tuning.</li> <li>Utilizes Explainable AI techniques to understand the model, the data on which the model is trained, and the most relevant spectral bands (important features) for the model.</li> <li>Covers the entire process with visualization of results.</li> </ul> <p>Info</p> <p>\ud83d\udcbb Code Repository</p>"},{"location":"examples/use_cases/#additional-information","title":"\ud83e\udd63 Additional information","text":"<p>The SiaPy library is designed to be flexible and extendable, making it suitable for a wide range of applications in hyperspectral imaging and analysis. Whether you are working on research projects, developing machine learning models, or performing detailed spectral analysis, SiaPy provides the tools and functionality needed to achieve your goals.</p> <p>For more details, see API documentation.</p>"},{"location":"examples/visualization/","title":"Visualizations","text":"<p>The examples below demonstrate how to interactively select specific parts of an image and extract pixel values using a computer mouse.</p>"},{"location":"examples/visualization/#pixels","title":"Pixels","text":"<p>This example shows how to select individual pixels in an image.</p> <pre><code>from pathlib import Path\n\nfrom siapy.entities import SpectralImage\nfrom siapy.utils.plots import pixels_select_click\n\n# Set the path to the directory containing the data\n# !! ADJUST THIS PATH TO YOUR DATA DIRECTORY !!\ndata_dir = \"./docs/examples/data\"\n\n# Get arbitrary image\nheader_path_img0 = sorted(Path(data_dir).rglob(\"*.hdr\"))[1]\nimage_path_img0 = sorted(Path(data_dir).rglob(\"*.img\"))[1]\n\n# Load spectral image\nimage = SpectralImage.spy_open(\n    header_path=header_path_img0,\n    image_path=image_path_img0,\n)\n\n# Select pixels from the image\npixels = pixels_select_click(image)\n# ? Press enter to finish the selection\nprint(\"Pixels:\", pixels.df)\n</code></pre> <p>Source: <code>visualization_01.py</code></p> <p>The selected pixels are highlighted in the image below.</p> <p></p>"},{"location":"examples/visualization/#areas","title":"Areas","text":"<p>This example shows how to select areas within an image.</p> <pre><code>from pathlib import Path\n\nfrom siapy.entities import SpectralImage\nfrom siapy.utils.plots import pixels_select_lasso\n\n# Set the path to the directory containing the data\n# !! ADJUST THIS PATH TO YOUR DATA DIRECTORY !!\ndata_dir = \"./docs/examples/data\"\n\n# Get arbitrary image\nheader_path_img0 = sorted(Path(data_dir).rglob(\"*.hdr\"))[1]\nimage_path_img0 = sorted(Path(data_dir).rglob(\"*.img\"))[1]\n\n# Load spectral image\nimage = SpectralImage.spy_open(\n    header_path=header_path_img0,\n    image_path=image_path_img0,\n)\n\n# Select areas from the image\nareas = pixels_select_lasso(image)\n# ? Press enter to finish the selection\n\n# Print the selected areas\nfor i, area in enumerate(areas):\n    print(f\"Area {i}:\", area)\n</code></pre> <p>Source: <code>visualization_02.py</code></p> <p>The selected areas are highlighted in the image below.</p> <p></p>"}]}